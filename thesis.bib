% Encoding: UTF-8

@PhdThesis{Rockai15,
  author     = {Ro{\v c}kai, Petr},
  title      = {Model Checking Software [online]},
  school     = {Masaryk University, Faculty of Informatics, Brno},
  year       = {2015 [cit. 2017-06-10]},
  type       = {Doctoral theses, Dissertations},
  supervisor = {Barnat, Ji{\v r}{\' i}},
  url        = {http://is.muni.cz/th/139761/fi_d/},
}

@Article{King76,
  author     = {King, James C.},
  title      = {Symbolic Execution and Program Testing},
  journal    = {Commun. ACM},
  year       = {1976},
  volume     = {19},
  number     = {7},
  pages      = {385--394},
  month      = jul,
  issn       = {0001-0782},
  acmid      = {360252},
  address    = {New York, NY, USA},
  issue_date = {July 1976},
  keywords   = {program debugging, program proving, program testing, program verification, symbolic execution, symbolic interpretation},
  numpages   = {10},
  publisher  = {ACM},
}

@InBook{Khurshid03,
  pages     = {553--568},
  title     = {Generalized Symbolic Execution for Model Checking and Testing},
  publisher = {Springer Berlin Heidelberg},
  year      = {2003},
  author    = {Khurshid, Sarfraz and P{\u{a}}s{\u{a}}reanu, Corina S. and Visser, Willem},
  editor    = {Garavel, Hubert and Hatcliff, John},
  address   = {Berlin, Heidelberg},
  isbn      = {978-3-540-36577-8},
  booktitle = {Tools and Algorithms for the Construction and Analysis of Systems: 9th International Conference, TACAS 2003 Held as Part of the Joint European Conferences on Theory and Practice of Software, ETAPS 2003 Warsaw, Poland, April 7--11, 2003 Proceedings},
}

@InBook{Mrazek2016,
  pages     = {208--213},
  title     = {SymDIVINE: Tool for Control-Explicit Data-Symbolic State Space Exploration},
  publisher = {Springer International Publishing},
  year      = {2016},
  author    = {Mr{\'a}zek, Jan and Bauch, Petr and Lauko, Henrich and Barnat, Ji{\v{r}}{\'i}},
  editor    = {Bo{\v{s}}na{\v{c}}ki, Dragan and Wijs, Anton},
  address   = {Cham},
  isbn      = {978-3-319-32582-8},
  booktitle = {Model Checking Software: 23rd International Symposium, SPIN 2016, Co-located with ETAPS 2016, Eindhoven, The Netherlands, April 7-8, 2016, Proceedings},
}

@Book{Clarke99,
  title     = {Model checking},
  publisher = {MIT press},
  year      = {1999},
  author    = {Clarke, Edmund M and Grumberg, Orna and Peled, Doron},
}

@InProceedings{Barnat14,
  author    = {Barnat, Ji{\v{r}}{\'i} and Bauch, Petr and Havel, Vojta},
  title     = {Model Checking Parallel Programs with Inputs},
  booktitle = {2014 22nd Euromicro International Conference on Parallel, Distributed, and Network-Based Processing},
  year      = {2014},
  pages     = {756-759},
  issn      = {1066-6192},
  keywords  = {computability;parallel programming;program verification;temporal logic;LTL model checking;explicit approach;input variables;linear temporal logic;noncanonical representations;parallel program model checking;parallel program verification;quantified bit-vector formulae;quantifier-free satisfiability;state matching;state space representation;state space searching;symbolic approach;Concrete;Educational institutions;Input variables;Model checking;Protocols;Scalability;Standards;bit-vector theory;concurrency verification;ltl model checking;satisfiability modulo theories},
}

@InProceedings{Lattner04,
  author    = {Lattner, Chris and Adve, Vikram},
  title     = {LLVM: A Compilation Framework for Lifelong Program Analysis \& Transformation},
  booktitle = {Proceedings of the International Symposium on Code Generation and Optimization: Feedback-directed and Runtime Optimization},
  year      = {2004},
  series    = {CGO '04},
  pages     = {75--},
  address   = {Washington, DC, USA},
  publisher = {IEEE Computer Society},
  acmid     = {977673},
  isbn      = {0-7695-2102-9},
  location  = {Palo Alto, California},
  url       = {http://dl.acm.org/citation.cfm?id=977395.977673},
}

@online{LLVM:web,
  author = {Chris Lattner},
  title  = {The \LLVM Compiler Infrastructure Project},
  url    = {http://llvm.org/},
  urldate = {2017-13-09},
  year = {2017}
}

@online{LLVM:langref,
  author = {{LLVM~Project}},
  title  = {LLVM Language Reference Manual},
  url    = {http://llvm.org/docs/LangRef.html},
  urldate = {2017-13-09},
  year = {2017}
}

@Book{Winskel93,
  title     = {The Formal Semantics of Programming Languages: An Introduction},
  publisher = {MIT Press},
  year      = {1993},
  author    = {Winskel, Glynn},
  address   = {Cambridge, MA, USA},
  isbn      = {0-262-23169-7},
}

@Article{Plotkin04,
  author  = {Gordon D{.} Plotkin},
  title   = {The origins of structural operational semantics},
  journal = {The Journal of Logic and Algebraic Programming},
  year    = {2004},
  volume  = {60},
  number  = {Supplement C},
  pages   = {3 - 15},
  issn    = {1567-8326},
  note    = {Structural Operational Semantics},
  url     = {http://www.sciencedirect.com/science/article/pii/S1567832604000268},
}

@Online{LLVM:opt,
  author  = {Chris Lattner},
  title   = {OPT \LLVM optimizer},
  year    = {2017},
  url     = {http://llvm.org/docs/CommandGuide/opt.html},
  urldate = {2017-23-09},
}

@Book{Baier08,
  title     = {Principles of Model Checking (Representation and Mind Series)},
  publisher = {The MIT Press},
  year      = {2008},
  author    = {Baier, Christel and Katoen, Joost-Pieter},
  isbn      = {026202649X, 9780262026499},
}

@Article{Clarke94,
  author     = {Clarke, Edmund M{.} and Grumberg, Orna and Long, David E{.}},
  title      = {Model Checking and Abstraction},
  journal    = {ACM Trans. Program. Lang. Syst.},
  year       = {1994},
  volume     = {16},
  number     = {5},
  pages      = {1512--1542},
  month      = sep,
  issn       = {0164-0925},
  acmid      = {186051},
  address    = {New York, NY, USA},
  issue_date = {Sept. 1994},
  keywords   = {abstract interpretation, binary decision diagrams (BDDs), model checking, temporal logic},
  numpages   = {31},
  publisher  = {ACM},
}

@Article{Divine17,
  author = {Baranov\'{a}, Zuzana and Barnat, Ji\v{r}\'{i} and  Kejstov\'{a}, Katar\'{i}na and Ku{\v c}era, Tade{\'{a}}{\v{s}} and  Lauko, Henrich and Mr{\'a}zek, Jan and  Ro{\v {c}}kai, Petr and  {\v{S}}till, Vladim\'{i}r},
  title  = {Model Checking of {C} and {C}++ with {DIVINE} 4},
  year   = {2017},
  note   = {Preliminary version.},
  url    = {https://divine.fi.muni.cz/2017/divine4},
}

@Article{RockaiCB17,
  author    = {Ro{\v c}kai, Petr and Ivana {\v C}ern{\'{a}} and Barnat, Ji\v{r}\'{i}},
  title     = {DiVM: Model Checking with {LLVM} and Graph Memory},
  journal   = {CoRR},
  year      = {2017},
  volume    = {abs/1703.05341},
  bibsource = {dblp computer science bibliography, http://dblp.org},
  biburl    = {http://dblp.uni-trier.de/rec/bib/journals/corr/RockaiCB17},
  timestamp = {Wed, 07 Jun 2017 14:42:01 +0200},
  url       = {http://arxiv.org/abs/1703.05341},
}

@MastersThesis{Still16,
  author     = {{\v S}till, Vladim\'ir},
  title      = {LLVM Transformations for Model Checking [online]},
  school     = {Masaryk University, Facult of Informatics, Brno},
  year       = {2016 [cit. 2017-10-08]},
  type       = {Diploma theses},
  supervisor = {Barnat, Ji\v{r}\'{i}},
  url        = {https://is.muni.cz/th/373979/fi_m/},
}

@InProceedings{Still17,
  author    = {{\v S}till, Vladim\'ir and Ro{\v c}kai, Petr and Barnat, Ji\v{r}\'{i}},
  title     = {{Using Off-the-Shelf Exception Support Components in C++ Verification}},
  booktitle = {IEEE International Conference on Software Quality, Reliability and Security (QRS)},
  year      = {2017},
  pages     = {54-64},
  month     = {July},
  keywords  = {C++ languages, Libraries, Software, Standards, Testing, Tools, C++, Exceptions, Model Checking, Unwinder, divine, exceptions, red hat},
  page      = {https://divine.fi.muni.cz/2017/exceptions/},
  url       = {http://ieeexplore.ieee.org/document/8009908/},
}

@InBook{Bauch14,
  pages     = {47--59},
  title     = {LTL Model Checking of LLVM Bitcode with Symbolic Data},
  publisher = {Springer International Publishing},
  year      = {2014},
  author    = {Bauch, Petr and Havel, Vojt{\v{e}}ch and Barnat, Ji{\v{r}}{\'i}},
  editor    = {Hlin{\v{e}}n{\'y}, Petr and Dvo{\v{r}}{\'a}k, Zden{\v{e}}k and Jaro{\v{s}}, Ji{\v{r}}{\'i} and Kofro{\v{n}}, Jan and Ko{\v{r}}enek, Jan and Matula, Petr and Pala, Karel},
  address   = {Cham},
  isbn      = {978-3-319-14896-0},
  abstract  = {The correctness of parallel and reactive programs is often easier specified using formulae of temporal logics. Yet verifying that a system satisfies such specifications is more difficult than verifying safety properties: the recurrence of a specific program state has to be detected. This paper reports on the development of a generic framework for automatic verification of linear temporal logic specifications for programs in LLVM bitcode. Our method searches explicitly through all possible interleavings of parallel threads (control non-determinism) but represents symbolically the variable evaluations (data non-determinism), guided by the specification in order to prove the correctness. To evaluate the framework we compare our method with state-of-the-art tools on a set of unmodified C programs.},
  booktitle = {Mathematical and Engineering Methods in Computer Science: 9th International Doctoral Workshop, MEMICS 2014, Tel{\v{c}}, Czech Republic, October 17--19, 2014, Revised Selected Papers},
}

@InBook{Rockai13,
  pages     = {1--15},
  title     = {Improved State Space Reductions for LTL Model Checking of C and C++ Programs},
  publisher = {Springer Berlin Heidelberg},
  year      = {2013},
  author    = {Ro{\v{c}}kai, Petr and Barnat, Ji{\v{r}}{\'i} and Brim, Lubo{\v{s}}},
  editor    = {Brat, Guillaume and Rungta, Neha and Venet, Arnaud},
  address   = {Berlin, Heidelberg},
  isbn      = {978-3-642-38088-4},
  abstract  = {In this paper, we present substantial improvements in efficiency of explicit-state LTL model checking of C {\&} C++ programs, building on [2], including improvements to state representation and to state space reduction techniques. The improved state representation allows to easily exploit symmetries in heap configurations of the program, especially in programs with interleaved heap allocations. Finally, we present a major improvement through a semi-dynamic proviso for partial-order reduction, based on eager local searches constrained through control-flow loop detection.},
  booktitle = {NASA Formal Methods: 5th International Symposium, NFM 2013, Moffett Field, CA, USA, May 14-16, 2013. Proceedings},
}

@MastersThesis{Havel14,
  author     = {Havel, Vojt{\v e}ch},
  title      = {Generic Platform for Explicit-Symbolic Verification [online]},
  school     = {Masaryk University, Faculty of Informatics, Brno},
  year       = {2014 [cit. 2017-10-14]},
  type       = {Diploma theses},
  supervisor = {Barnat, Ji{\v r}{\'i} },
  url        = {http://is.muni.cz/th/359437/fi_m/},
}

@Article{Cytron91,
  author     = {Cytron, Ron and Ferrante, Jeanne and Rosen, Barry K. and Wegman, Mark N. and Zadeck, F. Kenneth},
  title      = {Efficiently Computing Static Single Assignment Form and the Control Dependence Graph},
  journal    = {ACM Trans. Program. Lang. Syst.},
  year       = {1991},
  volume     = {13},
  number     = {4},
  pages      = {451--490},
  month      = oct,
  issn       = {0164-0925},
  acmid      = {115320},
  address    = {New York, NY, USA},
  issue_date = {Oct. 1991},
  keywords   = {control dependence, control flow graph, def-use chain, dominator, optimizing compilers},
  numpages   = {40},
  publisher  = {ACM},
}

@InProceedings{Hadarean14,
  author = {Liana Hadarean},
  title  = {An Efficient and Trustworthy Theory Solver for Bit-vectors in Satisfiability Modulo Theories},
  year   = {2014},
}

@InProceedings{duret04,
  author      = {Duret-Lutz, Alexandre and Poitrenaud, Denis},
  title       = {{SPOT: an Extensible Model Checking Library using Transition-based Generalized B{\"u}chi Automata}},
  booktitle   = {{12th IEEE/ACM International Symposium on Modeling, Analysis, and Simulation of Computer and Telecommunication Systems (MASCOTS '04)}},
  year        = {2004},
  pages       = {76-83},
  address     = {Volendam, Netherlands},
  month       = Oct,
  publisher   = {{IEEE Computer Society Press}},
  hal_id      = {hal-01496158},
  hal_version = {v1},
  url         = {https://hal.archives-ouvertes.fr/hal-01496158},
}

@InBook{Vardi96,
  pages     = {238--266},
  title     = {An automata-theoretic approach to linear temporal logic},
  publisher = {Springer Berlin Heidelberg},
  year      = {1996},
  author    = {Vardi, Moshe Y.},
  editor    = {Moller, Faron and Birtwistle, Graham},
  address   = {Berlin, Heidelberg},
  isbn      = {978-3-540-49675-5},
  abstract  = {The automata-theoretic approach to linear temporal logic uses the theory of automata as a unifying paradigm
for program specification, verification, and synthesis. Both programs and specifications are in essence descriptions
of computations. These computations can be viewed as words over some alphabet. Thus, programs and specifications can
be viewed as descriptions of languages over some alphabet. The automata-theoretic perspective considers the
relationships between programs and their specifications as relationships between languages. By translating programs
and specifications to automata, questions about programs and their specifications can be reduced to questions about
automata. More specifically, questions such as satisfiability of specifications and correctness of programs with
respect to their specifications can be reduced to questions such as nonemptiness and containment of automata.},
  booktitle = {Logics for Concurrency: Structure versus Automata},
}

@Book{Manna92,
  title     = {The Temporal Logic of Reactive and Concurrent Systems},
  publisher = {Springer-Verlag New York, Inc.},
  year      = {1992},
  author    = {Manna, Zohar and Pnueli, Amir},
  address   = {New York, NY, USA},
  isbn      = {0-387-97664-7},
}

@InBook{Clarke96,
  pages     = {419--422},
  title     = {Symbolic model checking},
  publisher = {Springer Berlin Heidelberg},
  year      = {1996},
  author    = {Clarke, E. and McMillan, K. and Campos, S. and Hartonas-Garmhausen, V.},
  editor    = {Alur, Rajeev and Henzinger, Thomas A.},
  address   = {Berlin, Heidelberg},
  isbn      = {978-3-540-68599-9},
  abstract  = {Symbolic model checking is a powerful formal specification and
verification method that has been applied successfully in several industrial
designs. Using symbolic model checking techniques it is possible to verify
industrial-size finite state systems. State spaces with up to 1030 states can
be exhaustively searched in minutes. Models with more than 10120 states have
been verified using special techniques.},
  booktitle = {Computer Aided Verification: 8th International Conference, CAV '96 New Brunswick, NJ, USA, July 31-- August 3, 1996 Proceedings},
}

@Book{McMillan93,
  title     = {Symbolic Model Checking},
  publisher = {Kluwer Academic Publishers},
  year      = {1993},
  author    = {McMillan, Kenneth L.},
  address   = {Norwell, MA, USA},
  isbn      = {0792393805},
}

@Article{Cimatti20,
  author   = {Cimatti, Alessandro and Clarke, Edmund and Giunchiglia, Fausto and Roveri, Marco},
  title    = {NUSMV: a new symbolic model checker},
  journal  = {International Journal on Software Tools for Technology Transfer},
  year     = {2000},
  volume   = {2},
  number   = {4},
  pages    = {410--425},
  month    = {Mar},
  issn     = {1433-2779},
  abstract = {This paper describes a new symbolic model checker, called NuSMV, developed as part of a joint project between CMU and IRST. NuSMV is the result of the reengineering, reimplementation and, to a limited extent, extension of the CMU SMV model checker. The core of this paper consists of a detailed description of the NuSMV functionalities, architecture, and implementation.},
  day      = {01},
}

@InBook{Kwiatkowska20,
  pages     = {200--204},
  title     = {PRISM: Probabilistic Symbolic Model Checker},
  publisher = {Springer Berlin Heidelberg},
  year      = {2002},
  author    = {Kwiatkowska, Marta and Norman, Gethin and Parker, David},
  editor    = {Field, Tony and Harrison, Peter G. and Bradley, Jeremy and Harder, Uli},
  address   = {Berlin, Heidelberg},
  isbn      = {978-3-540-46029-9},
  abstract  = {In this paper we describe PRISM, a tool being developed at the University of Birmingham for the analysis of probabilistic systems. PRISM supports three probabilistic models: discrete-time Markov chains, Markov decision processes and continuous-time Markov chains. Analysis is performed through model checking such systems against specifications written in the probabilistic temporal logics PCTL and CSL. The tool features three model checking engines: one symbolic, using BDDs (binary decision diagrams) and MTBDDs (multi-terminal BDDs); one based on sparse matrices; and one which combines both symbolic and sparse matrix methods. PRISM has been successfully used to analyse probabilistic termination, performance, and quality of service properties for a range of systems, including randomized distributed algorithms, manufacturing systems and workstation clusters.},
  booktitle = {Computer Performance Evaluation: Modelling Techniques and Tools: 12th International Conference, TOOLS 2002 London, UK, April 14--17, 2002 Proceedings},
}

@Article{Havelund20,
  author   = {Havelund, Klaus and Pressburger, Thomas},
  title    = {Model checking JAVA programs using JAVA PathFinder},
  journal  = {International Journal on Software Tools for Technology Transfer},
  year     = {2000},
  volume   = {2},
  number   = {4},
  pages    = {366--381},
  month    = {Mar},
  issn     = {1433-2779},
  abstract = {This paper describes a translator called Java PathFinder (Jpf), which translates from Java to Promela, the modeling language of the Spin model checker. Jpf translates a given Java program into a Promela model, which then can be model checked using Spin. The Java program may contain assertions, which are translated into similar assertions in the Promela model. The Spin model checker will then look for deadlocks and violations of any stated assertions. Jpf generates a Promela model with the same state space characteristics as the Java program. Hence, the Java program must have a finite and tractable state space. This work should be seen in a broader attempt to make formal methods applicable within NASA's areas such as space, aviation, and robotics. The work is a continuation of an effort to formally analyze, using Spin, a multi-threaded operating system for the Deep-Space 1 space craft, and of previous work in applying existing model checkers and theorem provers to real applications.},
  day      = {01},
}

@Article{Cousot14,
  author = {Cousot, Patrick and Cousot, Radhia},
  title  = {Abstract interpretation: past, present and future},
  year   = {2014},
  month  = {07},
  isbn   = {978-1-4503-2886-9},
}

@Article{Holzmann97,
  author     = {Holzmann, Gerard J.},
  title      = {The Model Checker SPIN},
  journal    = {IEEE Trans. Softw. Eng.},
  year       = {1997},
  volume     = {23},
  number     = {5},
  pages      = {279--295},
  month      = may,
  issn       = {0098-5589},
  acmid      = {260902},
  address    = {Piscataway, NJ, USA},
  issue_date = {May 1997},
  keywords   = {Formal methods, program verification, design verification, model checking, distributed systems, concurrency.},
  numpages   = {17},
  publisher  = {IEEE Press},
}

@InProceedings{redlib,
  author    = {F. Wang},
  title     = {REDLIB for the Formal Verification of Embedded Systems},
  booktitle = {Second International Symposium on Leveraging Applications of Formal Methods, Verification and Validation (isola 2006)},
  year      = {2006},
  pages     = {341-346},
  month     = {Nov},
  keywords  = {Boolean functions;automata theory;embedded systems;formal verification;Boolean operations;dense-time automata;dense-time state-space;dynamic memory allocation;embedded systems;formal verification;linear hybrid systems;parametric safety analysis;state-space operations;state-space representation normalizations;Automata;Boolean functions;Data structures;Embedded system;Formal verification;Graphical user interfaces;Hardware;Safety;Software libraries;System recovery},
}

@Article{Flanagan02,
  author     = {Flanagan, Cormac and Qadeer, Shaz},
  title      = {Predicate Abstraction for Software Verification},
  journal    = {SIGPLAN Not.},
  year       = {2002},
  volume     = {37},
  number     = {1},
  pages      = {191--202},
  month      = jan,
  issn       = {0362-1340},
  acmid      = {503291},
  address    = {New York, NY, USA},
  issue_date = {Jan. 2002},
  numpages   = {12},
  publisher  = {ACM},
}

@InProceedings{Beyer17,
  author    = {Beyer, Dirk},
  title     = {Software Verification with Validation of Results},
  booktitle = {Proceedings, Part II, of the 23rd International Conference on Tools and Algorithms for the Construction and Analysis of Systems - Volume 10206},
  year      = {2017},
  pages     = {331--349},
  address   = {New York, NY, USA},
  publisher = {Springer-Verlag New York, Inc.},
  acmid     = {3080481},
  isbn      = {978-3-662-54579-9},
  numpages  = {19},
}

@InBook{Clarke20,
  pages     = {154--169},
  title     = {Counter\-example-Guided Abstraction Refinement},
  publisher = {Springer Berlin Heidelberg},
  year      = {2000},
  author    = {Clarke, Edmund and Grumberg, Orna and Jha, Somesh and Lu, Yuan and Veith, Helmut},
  editor    = {Emerson, E. Allen and Sistla, Aravinda Prasad},
  address   = {Berlin, Heidelberg},
  isbn      = {978-3-540-45047-4},
  abstract  = {We present an automatic iterative abstraction-refinement methodology in which the initial abstract model is generated by an automatic analysis of the control structures in the program to be verified. Abstract models may admit erroneous (or ``spurious'') counterexamples. We devise new symbolic techniques which analyze such counterexamples and refine the abstract model correspondingly. The refinement algorithm keeps the size of the abstract state space small due to the use of abstraction functions which distinguish many degrees of abstraction for each program variable. We describe an implementation of our methodology in NuSMV. Practical experiments including a large Fujitsu IP core design with about 500 latches and 10000 lines of SMV code confirm the effectiveness of our approach.},
  booktitle = {Computer Aided Verification: 12th International Conference, CAV 2000, Chicago, IL, USA, July 15-19, 2000. Proceedings},
}

@Online{svcomp,
  author  = {Dirk Beyer},
  title   = {SV-COMP Rules},
  year    = {2017},
  url     = {https://sv-comp.sosy-lab.org/2017/rules.php},
  urldate = {2017-12-02},
}

@InProceedings{SVCOMP2019,
    author="Beyer, Dirk",
    editor="Beyer, Dirk
    and Huisman, Marieke
    and Kordon, Fabrice
    and Steffen, Bernhard",
    title="Automatic Verification of C and Java Programs: SV-COMP 2019",
    booktitle="Tools and Algorithms for the Construction and Analysis of Systems",
    year="2019",
    publisher="Springer International Publishing",
    address="Cham",
    pages="133--155",
    isbn="978-3-030-17502-3"
}

@Article{Jonas17,
  author        = {{Mr{\'a}zek}, Jan and {Jon{\'a}{\v s}}, Martin and {Barnat}, Ji{\v{r}}{\'i}},
  title         = {{SMT Queries Decomposition and Caching in Semi-Symbolic Model Checking}},
  journal       = {ArXiv e-prints},
  year          = {2017},
  month         = nov,
  adsnote       = {Provided by the SAO/NASA Astrophysics Data System},
  adsurl        = {http://adsabs.harvard.edu/abs/2017arXiv171109084M},
  archiveprefix = {arXiv},
  eprint        = {1711.09084},
  keywords      = {Computer Science - Programming Languages, Computer Science - Logic in Computer Science},
  primaryclass  = {cs.PL},
}

@InProceedings{Barrett2010,
  author    = {Barrett, Clark and Stump, Aaron and Tinelli, Cesare and others},
  title     = {The smt-lib standard: Version 2.0},
  booktitle = {Proceedings of the 8th International Workshop on Satisfiability Modulo Theories (Edinburgh, England)},
  year      = {2010},
  volume    = {13},
  pages     = {14},
}

@InCollection{Yang2008,
  author    = {Yang, Hongseok and Lee, Oukseh and Berdine, Josh and Calcagno, Cristiano and Cook, Byron and Distefano, Dino and O'Hearn, Peter},
  title     = {Scalable Shape Analysis for Systems Code},
  booktitle = {Computer Aided Verification},
  publisher = {Springer},
  year      = {2008},
  month     = jan,
  isbn      = {978-3-540-70543-7},
  abstract  = {Pointer safety faults in device drivers are one of the leading causes of crashes in operating systems code. In principle, shape analysis tools can be used to prove the absence of this type of error. In practice, however, shape analysis is not used due to the unacceptable mixture of scalability and precision provided by existing tools. In this paper we report on a new join operation ${\sqcup\dagger}$ for the separation domain which aggressively abstracts information for scalability yet does not lead to false error reports. ${\sqcup\dagger}$ is a critical piece of a new shape analysis tool that provides an acceptable mixture of scalability and precision for industrial application. Experiments on whole Windows and Linux device drivers (firewire, pci-driver, cdrom, md, etc.) represent the first working application of shape analysis to verification of whole industrial programs.},
  date      = {2008-01-01},
  doi       = {10.1007/978-3-540-70545-1_36},
  url       = {http://dx.doi.org/10.1007/978-3-540-70545-1_36},
}

@InProceedings{Henzinger2002,
  author    = {Henzinger, Thomas A. and Jhala, Ranjit and Majumdar, Rupak and Sutre, Gr{\'e}goire},
  title     = {Lazy Abstraction},
  booktitle = {Proceedings of the 29th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  year      = {2002},
  series    = {POPL '02},
  pages     = {58--70},
  address   = {New York, NY, USA},
  publisher = {ACM},
  acmid     = {503279},
  doi       = {10.1145/503272.503279},
  isbn      = {1-58113-450-9},
  location  = {Portland, Oregon},
  numpages  = {13},
  url       = {http://doi.acm.org/10.1145/503272.503279},
}

@InProceedings{Burch1990,
  author    = {J. R. {Burch} and E. M. {Clarke} and K. L. {McMillan} and D. L. {Dill} and L. J. {Hwang}},
  title     = {Symbolic model checking: 10\textsuperscript{20} states and beyond},
  booktitle = {Proc. Fifth Annual IEEE Symp. Logic in Computer Science [1990]},
  year      = {1990},
  pages     = {428--439},
  month     = jun,
  doi       = {10.1109/LICS.1990.113767},
  keywords  = {finite automata, specification languages, temporal logic, symbolic mu-calculus, iterative squaring transformation, PTL, binary decision diagrams, computation tree logic, mu-calculus, specification language, model-checking algorithm, binary decision diagrams, efficient decision procedures, CTL model checking, satisfiability, linear-time temporal logic formulas, observational equivalence, finite transition systems, language containment, finite omega -automata, complicated graph-traversal, nested fixed-point computations, decision procedure, symbolic model checking, synchronous pipeline, State-space methods, Data structures, Boolean functions, Logic testing, Explosions, Computer science, Pipelines, US Department of Defense, Contracts, Scholarships},
}

@Article{Majumdar2018,
  author    = {Majumdar, Rupak and Raskin, Jean-Francois},
  title     = {Symbolic Model Checking in Non-Boolean Domains},
  journal   = {Handbook of Model Checking},
  year      = {2018},
  month     = jan,
  date      = {2018-01-01},
  doi       = {10.1007/978-3-319-10575-8_31},
  publisher = {Springer},
  url       = {http://dx.doi.org/10.1007/978-3-319-10575-8_31},
}

@Article{Namjoshi2018,
  author    = {Namjoshi, Kedar S. and Pavlinovic, Zvonimir},
  title     = {The Impact of Program Transformations on Static Program Analysis},
  journal   = {Static Analysis},
  year      = {2018},
  month     = jan,
  abstract  = {Semantics-preserving program transformations, such as those carried out by an optimizing compiler, can affect the results of static program analyses. In the best cases, a transformation increases precision or allows a simpler analysis to replace a complex one. In other cases, transformations have the opposite effect, reducing precision. This work constructs a theoretical framework to analyze this intriguing phenomenon. The framework provides a simple, uniform explanation for precision changes, linking them to bisimulation relations that justify the correctness of a transformation. It offers a mechanism for recovering lost precision through the systematic construction of a new, bisimulating analysis. Furthermore, it is shown that program analyses defined over a class of composite domains can be factored into a program transformation followed by simpler, equally precise analyses of the target program.},
  date      = {2018-01-01},
  doi       = {10.1007/978-3-319-99725-4_19},
  publisher = {Springer},
  url       = {http://dx.doi.org/10.1007/978-3-319-99725-4_19},
}

@Article{Payet2018,
  author    = {Payet, Etienne and Spoto, Fausto},
  title     = {Checking Array Bounds by Abstract Interpretation and Symbolic Expressions},
  journal   = {Automated Reasoning},
  year      = {2018},
  month     = jan,
  abstract  = {Array access out of bounds is a typical programming error. From the '70s, static analysis has been used to identify where such errors actually occur at runtime, through abstract interpretation into linear constraints. However, feasibility and scalability to modern object-oriented code has not been established yet. This article builds on previous work on linear constraints and shows that the result does not scale, when polyhedra implement the linear constraints, while the more abstract zones scale to the analysis of medium-size applications. Moreover, this article formalises the inclusion of symbolic expressions in the constraints and shows that this improves its precision. Expressions are automatically selected on-demand. The resulting analysis applies to code with dynamic memory allocation and arrays held in expressions. It is sound, also in the presence of arbitrary side-effects. It is fully defined in the abstract interpretation framework and does not use any code instrumentation. Its proof of correctness, its implementation inside the commercial Julia analyzer and experiments on third-party code complete the work.},
  date      = {2018-01-01},
  doi       = {10.1007/978-3-319-94205-6_46},
  publisher = {Springer},
  url       = {http://dx.doi.org/10.1007/978-3-319-94205-6_46},
}

@Article{Bakhirkin2017,
  author    = {Bakhirkin, Alexey and Monniaux, David},
  title     = {Combining Forward and Backward Abstract Interpretation of Horn Clauses},
  journal   = {Static Analysis},
  year      = {2017},
  month     = jan,
  abstract  = {Alternation of forward and backward analyses is a standard technique in abstract interpretation of programs, which is in particular useful when we wish to prove unreachability of some undesired program states. The current state-of-the-art technique for combining forward (bottom-up, in logic programming terms) and backward (top-down) abstract interpretation of Horn clauses is query-answer transformation. It transforms a system of Horn clauses, such that standard forward analysis can propagate constraints both forward, and backward from a goal. Query-answer transformation is effective, but has issues that we wish to address. For that, we introduce a new backward collecting semantics, which is suitable for alternating forward and backward abstract interpretation of Horn clauses. We show how the alternation can be used to prove unreachability of the goal and how every subsequent run of an analysis yields a refined model of the system. Experimentally, we observe that combining forward and backward analyses is important for analysing systems that encode questions about reachability in C programs. In particular, the combination that follows our new semantics improves the precision of our own abstract interpreter, including when compared to a forward analysis of a query-answer-transformed system.},
  date      = {2017-01-01},
  doi       = {10.1007/978-3-319-66706-5_2},
  publisher = {Springer},
  url       = {http://dx.doi.org/10.1007/978-3-319-66706-5_2},
}

@Article{Cousot2015,
  author    = {Cousot, Patrick},
  title     = {Abstracting Induction by Extrapolation and Interpolation},
  journal   = {Verification, Model Checking, and Abstract Interpretation},
  year      = {2015},
  month     = jan,
  abstract  = {We introduce a unified view of induction performed by automatic verification tools to prove a given program specification This unification is done in the abstract interpretation framework using extrapolation (widening/dual-widening) and interpolation (narrowing, dual-narrowing, which are equivalent up to the exchange of the parameters). Dual-narrowing generalizes Craig interpolation in First Order Logic pre-ordered by implication to arbitrary abstract domains. An increasing iterative static analysis using extrapolation of successive iterates by widening followed by a decreasing iterative static analysis using interpolation of successive iterates by narrowing (both bounded by the specification) can be further improved by a increasing iterative static analysis using interpolation of iterates with the specification by dual-narrowing until reaching a fixpoint and checking whether it is inductive for the specification.},
  date      = {2015-01-01},
  doi       = {10.1007/978-3-662-46081-8_2},
  publisher = {Springer},
  url       = {http://dx.doi.org/10.1007/978-3-662-46081-8_2},
}

@Article{Chen2015,
  author    = {Chen, Junjie and Cousot, Patrick},
  title     = {A Binary Decision Tree Abstract Domain Functor},
  journal   = {Static Analysis},
  year      = {2015},
  month     = jan,
  abstract  = {We present an abstract domain functor whose elements are binary decision trees. It is parameterized by decision nodes which are a set of boolean tests appearing in the programs and by a numerical or symbolic abstract domain whose elements are the leaves. We first define the branch condition path abstraction which forms the decision nodes of the binary decision trees. It also provides a new prospective on partitioning the trace semantics of programs as well as separating properties in the leaves. We then discuss our binary decision tree abstract domain functor by giving algorithms for inclusion test, meet and join, transfer functions and extrapolation operators. We think the binary decision tree abstract domain functor may provide a flexible way of adjusting the cost/precision ratio in path-dependent static analysis.},
  date      = {2015-01-01},
  doi       = {10.1007/978-3-662-48288-9_3},
  publisher = {Springer},
  url       = {http://dx.doi.org/10.1007/978-3-662-48288-9_3},
}

@Article{Cousot2012,
  author    = {Cousot, Patrick},
  title     = {Formal Verification by Abstract Interpretation},
  journal   = {NASA Formal Methods},
  year      = {2012},
  month     = jan,
  abstract  = {We provide a rapid overview of the theoretical foundations and main applications of abstract interpretation and show that it currently provides scaling solutions to achieving assurance in mission- and safety-critical systems through verification by fully automatic, semantically sound and precise static program analysis.},
  date      = {2012-01-01},
  doi       = {10.1007/978-3-642-28891-3_3},
  publisher = {Springer},
  url       = {http://dx.doi.org/10.1007/978-3-642-28891-3_3},
}

@Article{Cousot2012a,
  author    = {Cousot, Patrick and Monerau, Michael},
  title     = {Probabilistic Abstract Interpretation},
  journal   = {Programming Languages and Systems},
  year      = {2012},
  month     = jan,
  abstract  = {Abstract interpretation has been widely used for verifying properties of computer systems. Here, we present a way to extend this framework to the case of probabilistic systems.The probabilistic abstraction framework that we propose allows us to systematically lift any classical analysis or verification method to the probabilistic setting by separating in the program semantics the probabilistic behavior from the (non-)deterministic behavior. This separation provides new insights for designing novel probabilistic static analyses and verification methods.We define the concrete probabilistic semantics and propose different ways to abstract them. We provide examples illustrating the expressiveness and effectiveness of our approach.},
  date      = {2012-01-01},
  doi       = {10.1007/978-3-642-28869-2_9},
  publisher = {Springer},
  url       = {http://dx.doi.org/10.1007/978-3-642-28869-2_9},
}

@Article{Cousot2011,
  author    = {Cousot, Patrick and Cousot, Radhia and Mauborgne, Laurent},
  title     = {Logical Abstract Domains and Interpretations},
  journal   = {The Future of Software Engineering},
  year      = {2011},
  month     = jan,
  abstract  = {We give semantic foundations to abstract domains consisting in first order logic formulae in a theory, as used in verification tools or methods using SMT-solvers or theorem provers.We exhibit conditions for a sound usage of such methods with respect to multi-interpreted semantics and extend their usage to automatic invariant generation by abstract interpretation.},
  date      = {2011-01-01},
  doi       = {10.1007/978-3-642-15187-3_3},
  publisher = {Springer},
  url       = {http://dx.doi.org/10.1007/978-3-642-15187-3_3},
}

@Article{Chen2008,
  author    = {Chen, Liqian and Miné, Antoine and Cousot, Patrick},
  title     = {A Sound Floating-Point Polyhedra Abstract Domain},
  journal   = {Programming Languages and Systems},
  year      = {2008},
  month     = jan,
  abstract  = {The polyhedra abstract domain is one of the most powerful and commonly used numerical abstract domains in the field of static program analysis based on abstract interpretation. In this paper, we present an implementation of the polyhedra domain using floating-point arithmetic without sacrificing soundness. Floating-point arithmetic allows a compact memory representation and an efficient implementation on current hardware, at the cost of some loss of precision due to rounding. Our domain is based on a constraint-only representation and employs sound floating-point variants of Fourier-Motzkin elimination and linear programming. The preliminary experimental results of our prototype are encouraging. To our knowledge, this is the first time that the polyhedra domain is adapted to floating-point arithmetic in a sound way.},
  date      = {2008-01-01},
  doi       = {10.1007/978-3-540-89330-1_2},
  publisher = {Springer},
  url       = {http://dx.doi.org/10.1007/978-3-540-89330-1_2},
}

@InProceedings{Cousot2015a,
  author    = {P. {Cousot}},
  title     = {On Various Abstract Understandings of Abstract Interpretation},
  booktitle = {Proc. Int. Symp. Theoretical Aspects of Software Engineering},
  year      = {2015},
  pages     = {2--3},
  month     = sep,
  doi       = {10.1109/TASE.2015.29},
  keywords  = {program diagnostics, abstract understanding, abstract interpretation theory, Semantics, Computer languages, Concrete, Interpolation, Presses, Extrapolation, Abstract Interpretation, Abstraction, Completeness, Formal methods, Semantics, Semantics, Soundness, Static analysis, Verification},
}

@Article{Beyer2018,
  author    = {Beyer, Dirk and Dangl, Matthias and Wendler, Philipp},
  title     = {A Unifying View on SMT-Based Software Verification},
  journal   = {Journal of Automated Reasoning},
  year      = {2018},
  volume    = {60},
  number    = {3},
  pages     = {299},
  month     = mar,
  issn      = {1573-0670},
  date      = {2018-03-01},
  doi       = {10.1007/s10817-017-9432-6},
  publisher = {Springer},
  url       = {http://dx.doi.org/10.1007/s10817-017-9432-6},
}

@Article{Beyer2018b,
  author    = {Beyer, Dirk and Gulwani, Sumit and Schmidt, David A.},
  title     = {Combining Model Checking and Data-Flow Analysis},
  journal   = {Handbook of Model Checking},
  year      = {2018},
  month     = jan,
  date      = {2018-01-01},
  doi       = {10.1007/978-3-319-10575-8_16},
  publisher = {Springer},
  url       = {http://dx.doi.org/10.1007/978-3-319-10575-8_16},
}

@Article{Beyer2018e,
  author    = {Beyer, Dirk and Friedberger, Karlheinz},
  title     = {In-Place vs. Copy-on-Write CEGAR Refinement for Block Summarization with Caching},
  journal   = {Leveraging Applications of Formal Methods, Verification and Validation. Verification},
  year      = {2018},
  month     = jan,
  date      = {2018-01-01},
  doi       = {10.1007/978-3-030-03421-4_14},
  publisher = {Springer},
  url       = {http://dx.doi.org/10.1007/978-3-030-03421-4_14},
}

@Article{Beyer2016,
  author    = {Beyer, Dirk and Lemberger, Thomas},
  title     = {Symbolic Execution with CEGAR},
  journal   = {Leveraging Applications of Formal Methods, Verification and Validation: Foundational Techniques},
  year      = {2016},
  month     = jan,
  abstract  = {Symbolic execution, a standard technique in program analysis, is a particularly successful and popular component in systems for test-case generation. One of the open research problems is that the approach suffers from the path-explosion problem. We apply abstraction to symbolic execution, and refine the abstract model using counterexample-guided abstraction refinement (Cegar), a standard technique from model checking. We also use refinement selection with existing and new heuristics to influence the behavior and further improve the performance of our refinement procedure. We implemented our new technique in the open-source software-verification framework CPAchecker. Our experimental results show that the implementation is highly competitive.},
  date      = {2016-01-01},
  doi       = {10.1007/978-3-319-47166-2_14},
  publisher = {Springer},
  url       = {http://dx.doi.org/10.1007/978-3-319-47166-2_14},
}

@Article{Beyer2016c,
  author    = {Beyer, Dirk and Dangl, Matthias},
  title     = {SMT-based Software Model Checking: An Experimental Comparison of Four Algorithms},
  journal   = {Verified Software. Theories, Tools, and Experiments},
  year      = {2016},
  month     = jan,
  date      = {2016-01-01},
  doi       = {10.1007/978-3-319-48869-1_14},
  publisher = {Springer},
  url       = {http://dx.doi.org/10.1007/978-3-319-48869-1_14},
}

@InCollection{Beyer2007,
  author    = {Beyer, Dirk and Henzinger, Thomas A. and Théoduloz, Grégory},
  title     = {Configurable Software Verification: Concretizing the Convergence of Model Checking and Program Analysis},
  booktitle = {Computer Aided Verification},
  publisher = {Springer},
  year      = {2007},
  month     = jan,
  isbn      = {978-3-540-73367-6},
  abstract  = {In automatic software verification, we have observed a theoretical convergence of model checking and program analysis. In practice, however, model checkers are still mostly concerned with precision, e.g., the removal of spurious counterexamples; for this purpose they build and refine reachability trees. Lattice-based program analyzers, on the other hand, are primarily concerned with efficiency. We designed an algorithm and built a tool that can be configured to perform not only a purely tree-based or a purely lattice-based analysis, but offers many intermediate settings that have not been evaluated before. The algorithm and tool take one or more abstract interpreters, such as a predicate abstraction and a shape analysis, and configure their execution and interaction using several parameters. Our experiments show that such customization may lead to dramatic improvements in the precision-efficiency spectrum.},
  date      = {2007-01-01},
  doi       = {10.1007/978-3-540-73368-3_51},
  url       = {http://dx.doi.org/10.1007/978-3-540-73368-3_51},
}

@InCollection{Beyer2006a,
  author    = {Beyer, Dirk and Henzinger, Thomas A. and Théoduloz, Grégory},
  title     = {Lazy Shape Analysis},
  booktitle = {Computer Aided Verification},
  publisher = {Springer},
  year      = {2006},
  month     = jan,
  isbn      = {978-3-540-37406-0},
  abstract  = {Many software model checkers are based on predicate abstraction. If the verification goal depends on pointer structures, the approach does not work well, because it is difficult to find adequate predicate abstractions for the heap. In contrast, shape analysis, which uses graph-based heap abstractions, can provide a compact representation of recursive data structures. We integrate shape analysis into the software model checker Blast. Because shape analysis is expensive, we do not apply it globally. Instead, we ensure that, like predicates, shape graphs are computed and stored locally, only where necessary for proving the verification goal. To achieve this, we extend lazy abstraction refinement, which so far has been used only for predicate abstractions, to three-valued logical structures. This approach does not only increase the precision of model checking, but it also increases the efficiency of shape analysis. We implemented the technique by extending Blast with calls to Tvla.},
  date      = {2006-01-01},
  doi       = {10.1007/11817963_48},
  url       = {http://dx.doi.org/10.1007/11817963_48},
}

@InProceedings{Cousot1977,
  author    = {Cousot, Patrick and Cousot, Radhia},
  title     = {Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints},
  booktitle = {Proceedings of the 4th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages},
  year      = {1977},
  series    = {POPL '77},
  pages     = {238--252},
  address   = {New York, NY, USA},
  publisher = {ACM},
  acmid     = {512973},
  doi       = {10.1145/512950.512973},
  location  = {Los Angeles, California},
  numpages  = {15},
  url       = {http://doi.acm.org/10.1145/512950.512973},
}

@InProceedings{Cousot1979,
  author    = {Cousot, Patrick and Cousot, Radhia},
  title     = {Systematic Design of Program Analysis Frameworks},
  booktitle = {Proceedings of the 6th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages},
  year      = {1979},
  series    = {POPL '79},
  pages     = {269--282},
  address   = {New York, NY, USA},
  publisher = {ACM},
  acmid     = {567778},
  doi       = {10.1145/567752.567778},
  location  = {San Antonio, Texas},
  numpages  = {14},
  url       = {http://doi.acm.org/10.1145/567752.567778},
}

@Article{Cousot1992,
  author     = {Cousot, Patrick and Cousot, Rahida},
  title      = {Abstract Interpretation and Application to Logic Programs},
  journal    = {J. Log. Program.},
  year       = {1992},
  volume     = {13},
  number     = {2-3},
  pages      = {103--179},
  month      = jul,
  issn       = {0743-1066},
  acmid      = {140970},
  address    = {New York, NY, USA},
  doi        = {10.1016/0743-1066(92)90030-7},
  issue_date = {July 1992},
  numpages   = {77},
  publisher  = {Elsevier Science Inc.},
  url        = {http://dx.doi.org/10.1016/0743-1066(92)90030-7},
}

@Article{Cousot1992b,
  author    = {Cousot, P{.} and Cousot, R{.}},
  title     = {Abstract Interpretation Frameworks},
  journal   = {Journal of Logic and Computation},
  year      = {1992},
  volume    = {2},
  number    = {4},
  pages     = {511--547},
  month     = auf,
  publisher = {Oxford University Press, Oxford, UK},
}

@InProceedings{Cousot1992a,
  author    = {Cousot, Patrick and Cousot, Radhia},
  title     = {Comparing the Galois Connection and Widening/Narrowing Approaches to Abstract Interpretation},
  booktitle = {Proceedings of the 4th International Symposium on Programming Language Implementation and Logic Programming},
  year      = {1992},
  series    = {PLILP '92},
  pages     = {269--295},
  address   = {Berlin, Heidelberg},
  publisher = {Springer-Verlag},
  acmid     = {692441},
  isbn      = {3-540-55844-6},
  numpages  = {27},
  url       = {http://dl.acm.org/citation.cfm?id=646448.692441},
}

@Article{Cortesi1995,
  author        = {Cortesi, Agostino and Filé, Gilberto and Giacobazzi, Roberto and Palamidessi, Catuscia and Ranzato, Francesco},
  title         = {Complementation in abstract interpretation},
  journal       = {Static Analysis},
  year          = {1995},
  month         = jan,
  abstract      = {The reduced product of abstract domains is a rather well known operation in abstract interpretation. In this paper we study the inverse operation, which we call complementation. Such an operation allows to systematically decompose domains; it provides a systematic way to design new abstract domains; it allows to simplify domain verification problems, like correctness proofs; and it yields space saving representations for domains. We show that the complement exists in most cases, and we apply complementation to two well known abstract domains, notably to the Cousot and Cousot's comportment domain for analysis of functional languages and to the complex domain Sharing for aliasing analysis of logic languages.},
  date          = {1995-01-01},
  doi           = {10.1007/3-540-60360-3_35},
  publisher     = {Springer},
  url           = {http://dx.doi.org/10.1007/3-540-60360-3_35},
}

@Book{Birkhoff1940,
  title     = {Lattice Theory},
  publisher = {American Mathematical Society},
  year      = {1940},
  author    = {Birkhoff, G.},
  number    = {v. 25, pt. 2},
  series    = {American Mathematical Society colloquium publications},
  isbn      = {9780821810255},
  lccn      = {66023707},
  url       = {https://books.google.cz/books?id=ePqVAwAAQBAJ},
}

@InProceedings{Kildall1973,
  author    = {Kildall, Gary A.},
  title     = {A Unified Approach to Global Program Optimization},
  booktitle = {Proceedings of the 1st Annual ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages},
  year      = {1973},
  series    = {POPL '73},
  pages     = {194--206},
  address   = {New York, NY, USA},
  publisher = {ACM},
  acmid     = {512945},
  doi       = {10.1145/512927.512945},
  location  = {Boston, Massachusetts},
  numpages  = {13},
  url       = {http://doi.acm.org/10.1145/512927.512945},
}

@Article{Tarski1955,
  author    = {Tarski, Alfred},
  title     = {A lattice-theoretical fixpoint theorem and its applications.},
  journal   = {Pacific J. Math.},
  year      = {1955},
  volume    = {5},
  number    = {2},
  pages     = {285--309},
  fjournal  = {Pacific Journal of Mathematics},
  publisher = {Pacific Journal of Mathematics, A Non-profit Corporation},
  url       = {https://projecteuclid.org:443/euclid.pjm/1103044538},
}

@Article{Mine2006,
  author        = {Miné, Antoine},
  title         = {The octagon abstract domain},
  journal       = {Higher-Order and Symbolic Computation},
  year          = {2006},
  volume        = {19},
  number        = {1},
  pages         = {31},
  month         = mar,
  date          = {2006-03-01},
  doi           = {10.1007/s10990-006-8609-1},
  publisher     = {Springer},
  url           = {http://dx.doi.org/10.1007/s10990-006-8609-1},
}

@InCollection{Mine2002,
  author        = {Miné, Antoine},
  title         = {A Few Graph-Based Relational Numerical Abstract Domains},
  booktitle     = {Static Analysis},
  publisher     = {Springer},
  year          = {2002},
  month         = jan,
  isbn          = {978-3-540-44235-6},
  date          = {2002-01-01},
  doi           = {10.1007/3-540-45789-5_11},
  url           = {http://dx.doi.org/10.1007/3-540-45789-5_11},
}

@Article{Granger1989,
  author    = {Philippe Granger},
  title     = {Static analysis of arithmetical congruences},
  journal   = {International Journal of Computer Mathematics},
  year      = {1989},
  volume    = {30},
  number    = {3-4},
  pages     = {165-190},
  doi       = {10.1080/00207168908803778},
  eprint    = {https://doi.org/10.1080/00207168908803778},
  publisher = {Taylor \& Francis},
  url       = {
        https://doi.org/10.1080/00207168908803778

},
}

@Article{Cortesi2011,
  author  = {Cortesi, Agostino and Zanioli, Matteo},
  title   = {Widening and narrowing operators for abstract interpretation},
  journal = {Computer Languages, Systems \& Structures},
  year    = {2011},
  volume  = {37},
  pages   = {24-42},
  month   = {04},
  doi     = {10.1016/j.cl.2010.09.001},
}

@InProceedings{Lakhdar2011,
  author    = {Lakhdar-Chaouch, 1Lies and Jeannet, Bertrand and Girault, Alain},
  title     = {Widening with Thresholds for Programs with Complex Control Graphs},
  booktitle = {Automated Technology for Verification and Analysis},
  year      = {2011},
  editor    = {Bultan, Tevfik and Hsiung, Pao-Ann},
  pages     = {492--502},
  address   = {Berlin, Heidelberg},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {The precision of an analysis based on abstract interpretation does not only depend on the abstract domain, but also on the solving method. The traditional solution is to solve iteratively abstract fixpoint equations, using extrapolation with a widening operator to make the iterations converge. Unfortunately, this extrapolation often loses crucial information for the analysis goal. A classical technique for improving the precision is ``widening with thresholds'', which bounds the extrapolation. Its benefit strongly depends on the choice of relevant thresholds. In this paper we propose a semantic-based technique for automatically inferring such thresholds, which applies to any control graph, be it intraprocedural, interprocedural or concurrent, without specific assumptions on the abstract domain. Despite its technical simplicity, our technique is able to infer the relevant thresholds in many practical cases.},
  isbn      = {978-3-642-24372-1},
}

@Article{Bagnara2008,
  author   = {Roberto Bagnara and Patricia M. Hill and Elisa Ricci and Enea Zaffanella},
  title    = {Precise widening operators for convex polyhedra},
  journal  = {Science of Computer Programming},
  year     = {2005},
  volume   = {58},
  number   = {1},
  pages    = {28 - 56},
  issn     = {0167-6423},
  note     = {Special Issue on the Static Analysis Symposium 2003},
  abstract = {In the context of static analysis via abstract interpretation, convex polyhedra constitute the most used abstract domain among those capturing numerical relational information. Since the domain of convex polyhedra admits infinite ascending chains, it has to be used in conjunction with appropriate mechanisms for enforcing and accelerating the convergence of fixpoint computations. Widening operators provide a simple and general characterization for such mechanisms. For the domain of convex polyhedra, the original widening operator proposed by Cousot and Halbwachs amply deserves the name of standard widening since most analysis and verification tools that employ convex polyhedra also employ that operator. Nonetheless, there is an unfulfilled demand for more precise widening operators. In this paper, after a formal introduction to the standard widening where we clarify some aspects that are often overlooked, we embark on the challenging task of improving on it. We present a framework for the systematic definition of new widening operators that are never less precise than a given widening. The framework is then instantiated on the domain of convex polyhedra so as to obtain a new widening operator that improves on the standard widening by combining several heuristics. A preliminary experimental evaluation has yielded promising results. We also suggest an improvement to the well-known widening delay technique that allows one to gain precision while preserving its overall simplicity.},
  doi      = {https://doi.org/10.1016/j.scico.2005.02.003},
  keywords = {Abstract interpretation, Widening operators, Convex polyhedra},
  url      = {http://www.sciencedirect.com/science/article/pii/S0167642305000432},
}

@Article{Blanchet2003,
  author     = {Blanchet, Bruno and Cousot, Patrick and Cousot, Radhia and Feret, J{\'e}rome and Mauborgne, Laurent and Min{\'e}, Antoine and Monniaux, David and Rival, Xavier},
  title      = {A Static Analyzer for Large Safety-critical Software},
  journal    = {SIGPLAN Not.},
  year       = {2003},
  volume     = {38},
  number     = {5},
  pages      = {196--207},
  month      = may,
  issn       = {0362-1340},
  acmid      = {781153},
  address    = {New York, NY, USA},
  doi        = {10.1145/780822.781153},
  issue_date = {May 2003},
  keywords   = {abstract domains, abstract interpretation, embedded, floating point, reactive, real-time, safety-critical software, static analysis, verification},
  numpages   = {12},
  publisher  = {ACM},
  url        = {http://doi.acm.org/10.1145/780822.781153},
}

@InProceedings{Gonnord2006,
  author    = {Gonnord, Laure and Halbwachs, Nicolas},
  title     = {Combining Widening and Acceleration in Linear Relation Analysis},
  booktitle = {Static Analysis},
  year      = {2006},
  editor    = {Yi, Kwangkeun},
  pages     = {144--160},
  address   = {Berlin, Heidelberg},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {Linear Relation Analysis [CH78, Hal79] is one of the first, but still one of the most powerful, abstract interpretations working in an infinite lattice. As such, it makes use of a widening operator to enforce the convergence of fixpoint computations. While the approximation due to widening can be arbitrarily refined by delaying the application of widening, the analysis quickly becomes too expensive with the increase of delay. Previous attempts at improving the precision of widening are not completely satisfactory, since none of them is guaranteed to improve the precision of the result, and they can nevertheless increase the cost of the analysis. In this paper, we investigate an improvement of Linear Relation Analysis consisting in computing, when possible, the exact (abstract) effect of a loop. This technique is fully compatible with the use of widening, and whenever it applies, it improves both the precision and the performance of the analysis.},
  isbn      = {978-3-540-37758-0},
}

@Article{Feautrier2010,
  author   = {Paul Feautrier and Laure Gonnord},
  title    = {Accelerated Invariant Generation for C Programs with Aspic and C2fsm},
  journal  = {Electronic Notes in Theoretical Computer Science},
  year     = {2010},
  volume   = {267},
  number   = {2},
  pages    = {3 - 13},
  issn     = {1571-0661},
  note     = {Proceedings of the Tools for Automatic Program AnalysiS (TAPAS)},
  doi      = {https://doi.org/10.1016/j.entcs.2010.09.014},
  keywords = {Abstract interpretation, polyhedral abstract domain, acceleration, fixpoint iteration, flowchat programs, compilation, tools},
  url      = {http://www.sciencedirect.com/science/article/pii/S157106611000143X},
}

@InProceedings{Costan2005,
  author    = {Costan, A. and Gaubert, S. and Goubault, E. and Martel, M. and Putot, S.},
  title     = {A Policy Iteration Algorithm for Computing Fixed Points in Static Analysis of Programs},
  booktitle = {Computer Aided Verification},
  year      = {2005},
  editor    = {Etessami, Kousha and Rajamani, Sriram K.},
  pages     = {462--475},
  address   = {Berlin, Heidelberg},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {We present a new method for solving the fixed point equations that appear in the static analysis of programs by abstract interpretation. We introduce and analyze a policy iteration algorithm for monotone self-maps of complete lattices. We apply this algorithm to the particular case of lattices arising in the interval abstraction of values of variables. We demonstrate the improvements in terms of speed and precision over existing techniques based on Kleene iteration, including traditional widening/narrowing acceleration mecanisms.},
  isbn      = {978-3-540-31686-2},
}

@InProceedings{Gaubert2007,
  author    = {Gaubert, Stephane and Goubault, Eric and Taly, Ankur and Zennou, Sarah},
  title     = {Static Analysis by Policy Iteration on Relational Domains},
  booktitle = {Programming Languages and Systems},
  year      = {2007},
  editor    = {De Nicola, Rocco},
  pages     = {237--252},
  address   = {Berlin, Heidelberg},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {We give a new practical algorithm to compute, in finite time, a fixpoint (and often the least fixpoint) of a system of equations in the abstract numerical domains of zones and templates used for static analysis of programs by abstract interpretation. This paper extends previous work on the non-relational domain of intervals to relational domains. The algorithm is based on policy iteration techniques-- rather than Kleene iterations as used classically in static analysis-- and generates from the system of equations a finite set of simpler systems that we call policies. This set of policies satisfies a selection property which ensures that the minimal fixpoint of the original system of equations is the minimum of the fixpoints of the policies. Computing a fixpoint of a policy is done by linear programming. It is shown, through experiments made on a prototype analyzer, compared in particular to analyzers such as LPInv or the Octagon Analyzer, to be in general more precise and faster than the usual Kleene iteration combined with widening and narrowing techniques.},
  isbn      = {978-3-540-71316-6},
}

@InProceedings{Gawlitza2007,
  author    = {Gawlitza, Thomas and Seidl, Helmut},
  title     = {Precise Fixpoint Computation Through Strategy Iteration},
  booktitle = {Programming Languages and Systems},
  year      = {2007},
  editor    = {De Nicola, Rocco},
  pages     = {300--315},
  address   = {Berlin, Heidelberg},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {We present a practical algorithm for computing least solutions of systems of equations over the integers with addition, multiplication with positive constants, maximum and minimum. The algorithm is based on strategy iteration. Its run-time (w.r.t. the uniform cost measure) is independent of the sizes of occurring numbers. We apply our technique to solve systems of interval equations. In particular, we show how arbitrary intersections as well as full interval multiplication in interval equations can be dealt with precisely.},
  isbn      = {978-3-540-71316-6},
}

@InProceedings{Gawlitza2007b,
  author    = {Gawlitza, Thomas and Seidl, Helmut},
  title     = {Precise Relational Invariants Through Strategy Iteration},
  booktitle = {Computer Science Logic},
  year      = {2007},
  editor    = {Duparc, Jacques and Henzinger, Thomas A.},
  pages     = {23--40},
  address   = {Berlin, Heidelberg},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {We present a practical algorithm for computing exact least solutions of systems of equations over the rationals with addition, multiplication with positive constants, minimum and maximum. The algorithm is based on strategy improvement combined with solving linear programming problems for each selected strategy. We apply our technique to compute the abstract least fixpoint semantics of affine programs over the relational template constraint matrix domain [20]. In particular, we thus obtain practical algorithms for computing the abstract least fixpoint semantics over the zone and octagon abstract domain.},
  isbn      = {978-3-540-74915-8},
}

@Article{Gawlitza2011,
  author     = {Gawlitza, Thomas Martin and Seidl, Helmut},
  title      = {Solving Systems of Rational Equations Through Strategy Iteration},
  journal    = {ACM Trans. Program. Lang. Syst.},
  year       = {2011},
  volume     = {33},
  number     = {3},
  pages      = {11:1--11:48},
  month      = may,
  issn       = {0164-0925},
  acmid      = {1961207},
  address    = {New York, NY, USA},
  articleno  = {11},
  doi        = {10.1145/1961204.1961207},
  issue_date = {April 2011},
  keywords   = {Static program analysis, abstract interpretation, fixpoint equation systems, recursive stochastic games, strategy improvement algorithms},
  numpages   = {48},
  publisher  = {ACM},
  url        = {http://doi.acm.org/10.1145/1961204.1961207},
}

@InProceedings{Cousot2011b,
  author    = {Cousot, Patrick and Cousot, Radhia and Mauborgne, Laurent},
  title     = {The Reduced Product of Abstract Domains and the Combination of Decision Procedures},
  booktitle = {Foundations of Software Science and Computational Structures},
  year      = {2011},
  editor    = {Hofmann, Martin},
  pages     = {456--472},
  address   = {Berlin, Heidelberg},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {The algebraic/model theoretic design of static analyzers uses abstract domains based on representations of properties and pre-calculated property transformers. It is very efficient. The logical/proof theoretic approach uses SMT solvers and computation on-the-fly of property transformers. It is very expressive. We propose a combination of the two approaches to reach the sweet spot best adapted to a specific application domain in the precision/cost spectrum. The proposed combination uses an iterated reduction to combine abstractions. The key observation is that the Nelson-Oppen procedure which decides satisfiability in a combination of logical theories by exchanging equalities and disequalities computes a reduced product (after the state is enhanced with some new ``observations'' corresponding to alien terms). By abandoning restrictions ensuring completeness (such as disjointness, convexity, stably-infiniteness or shininess, etc) we can even broaden the application scope of logical abstractions for static analysis (which is incomplete anyway). We also introduce a semantics based on multiple interpretations to deal with the soundness of that combinations on a formal basis.},
  isbn      = {978-3-642-19805-2},
}

@Article{Karr1976,
  author   = {Karr, Michael},
  title    = {Affine relationships among variables of a program},
  journal  = {Acta Informatica},
  year     = {1976},
  volume   = {6},
  number   = {2},
  pages    = {133--151},
  month    = {Jun},
  issn     = {1432-0525},
  abstract = {Several optimizations of programs can be performed when in certain regions of a program equality relationships hold between a linear combination of the variables of the program and a constant. This paper presents a practical approach to detecting these relationships by considering the problem from the viewpoint of linear algebra. Key to the practicality of this approach is an algorithm for the calculation of the ``sum'' of linear subspaces.},
  day      = {01},
  doi      = {10.1007/BF00268497},
  url      = {https://doi.org/10.1007/BF00268497},
}

@InProceedings{Granger1991,
  author    = {Granger, Philippe},
  title     = {Static analysis of linear congruence equalities among variables of a program},
  booktitle = {TAPSOFT '91},
  year      = {1991},
  editor    = {Abramsky, S. and Maibaum, T. S. E.},
  pages     = {169--192},
  address   = {Berlin, Heidelberg},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {This paper is dedicated to the presentation of a new static analysis of programs conceived for discovering linear congruence equations satisfied by integer valued variables (or more generally by any set of integer values abstracted from a program). This analysis generalizes both P. Granger's arithmetical congruence analysis and M. Karr's affine equation analysis. An example shows that it can provide valuable results for automatic vectorization.},
  isbn      = {978-3-540-46563-8},
}

@InProceedings{Cousot1978,
  author    = {Cousot, Patrick and Halbwachs, Nicolas},
  title     = {Automatic Discovery of Linear Restraints Among Variables of a Program},
  booktitle = {Proceedings of the 5th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages},
  year      = {1978},
  series    = {POPL '78},
  pages     = {84--96},
  address   = {New York, NY, USA},
  publisher = {ACM},
  acmid     = {512770},
  doi       = {10.1145/512760.512770},
  location  = {Tucson, Arizona},
  numpages  = {13},
  url       = {http://doi.acm.org/10.1145/512760.512770},
}

@Book{Schrijver1986,
  title     = {Theory of Linear and Integer Programming},
  publisher = {John Wiley \& Sons, Inc.},
  year      = {1986},
  author    = {Schrijver, Alexander},
  address   = {New York, NY, USA},
  isbn      = {0-471-90854-1},
}

@Article{Singh2017,
  author     = {Singh, Gagandeep and P\"{u}schel, Markus and Vechev, Martin},
  title      = {Fast Polyhedra Abstract Domain},
  journal    = {SIGPLAN Not.},
  year       = {2017},
  volume     = {52},
  number     = {1},
  pages      = {46--59},
  month      = jan,
  issn       = {0362-1340},
  acmid      = {3009885},
  address    = {New York, NY, USA},
  doi        = {10.1145/3093333.3009885},
  issue_date = {January 2017},
  keywords   = {Abstract interpretation, Numerical program analysis, Partitions, Performance optimization, Polyhedra decomposition},
  numpages   = {14},
  publisher  = {ACM},
  url        = {http://doi.acm.org/10.1145/3093333.3009885},
}

@InProceedings{Chen2009,
  author    = {Chen, Liqian and Min{\'e}, Antoine and Wang, Ji and Cousot, Patrick},
  title     = {Interval Polyhedra: An Abstract Domain to Infer Interval Linear Relationships},
  booktitle = {Static Analysis},
  year      = {2009},
  editor    = {Palsberg, Jens and Su, Zhendong},
  pages     = {309--325},
  address   = {Berlin, Heidelberg},
  publisher = {Springer Berlin Heidelberg},
  isbn      = {978-3-642-03237-0},
}

@InProceedings{Larsen1997,
  author    = {K. G. {Larsen} and F. {Larsson} and P. {Pettersson} and W. {Yi}},
  title     = {Efficient verification of real-time systems: compact data structure and state-space reduction},
  booktitle = {Proceedings Real-Time Systems Symposium},
  year      = {1997},
  pages     = {14-24},
  month     = {Dec},
  doi       = {10.1109/REAL.1997.641265},
  issn      = {1052-8725},
  keywords  = {reachability analysis;real-time systems;formal verification;automata theory;real-time systems verification;compact data structure;state-space reduction;timed automata;clock values;clock constraints;real-valued variables;static analysis;termination;reachability analysis;Real time systems;Data structures;Automata;Clocks;Automatic control;Electrical equipment industry;Industrial control;Algorithm design and analysis;Computer networks;Reachability analysis},
}

@InProceedings{Venet2004,
  author    = {Venet, Arnaud and Brat, Guillaume},
  title     = {Precise and Efficient Static Array Bound Checking for Large Embedded C Programs},
  booktitle = {Proceedings of the ACM SIGPLAN 2004 Conference on Programming Language Design and Implementation},
  year      = {2004},
  series    = {PLDI '04},
  pages     = {231--242},
  address   = {New York, NY, USA},
  publisher = {ACM},
  acmid     = {996869},
  doi       = {10.1145/996841.996869},
  isbn      = {1-58113-807-5},
  keywords  = {abstract interpretation, array-bound checking, difference-bound matrices, pointer analysis, program verification},
  location  = {Washington DC, USA},
  numpages  = {12},
  url       = {http://doi.acm.org/10.1145/996841.996869},
}

@Article{Logozzo2010,
  author   = {Francesco Logozzo and Manuel Fähndrich},
  title    = {Pentagons: A weakly relational abstract domain for the efficient validation of array accesses},
  journal  = {Science of Computer Programming},
  year     = {2010},
  volume   = {75},
  number   = {9},
  pages    = {796 - 807},
  issn     = {0167-6423},
  note     = {Special Issue on Object-Oriented Programming Languages and Systems (OOPS 2008), A Special Track at the 23rd ACM Symposium on Applied Computing},
  doi      = {https://doi.org/10.1016/j.scico.2009.04.004},
  keywords = {Abstract domains, Abstract interpretation, Bounds checking, Numerical domains, Static analysis, .NET framework},
  url      = {http://www.sciencedirect.com/science/article/pii/S0167642309000719},
}

@InProceedings{Claris2004,
  author    = {Claris{\'o}, Robert and Cortadella, Jordi},
  title     = {The Octahedron Abstract Domain},
  booktitle = {Static Analysis},
  year      = {2004},
  editor    = {Giacobazzi, Roberto},
  pages     = {312--327},
  address   = {Berlin, Heidelberg},
  publisher = {Springer Berlin Heidelberg},
  isbn      = {978-3-540-27864-1},
}

@InProceedings{Mine2004,
  author    = {Min{\'e}, Antoine},
  title     = {Relational Abstract Domains for the Detection of Floating-Point Run-Time Errors},
  booktitle = {Programming Languages and Systems},
  year      = {2004},
  editor    = {Schmidt, David},
  pages     = {3--17},
  address   = {Berlin, Heidelberg},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {We present a new idea to adapt relational abstract domains to the analysis of IEEE 754-compliant floating-point numbers in order to statically detect, through Abstract Interpretation-based static analyses, potential floating-point run-time exceptions such as overflows or invalid operations. In order to take the non-linearity of rounding into account, expressions are modeled as linear forms with interval coefficients. We show how to extend already existing numerical abstract domains, such as the octagon abstract domain, to efficiently abstract transfer functions based on interval linear forms. We discuss specific fixpoint stabilization techniques and give some experimental results.},
  isbn      = {978-3-540-24725-8},
}

@Article{Amato2017,
  author   = {Gianluca Amato and Marco Rubino and Francesca Scozzari},
  title    = {Inferring linear invariants with parallelotopes},
  journal  = {Science of Computer Programming},
  year     = {2017},
  volume   = {148},
  pages    = {161 - 188},
  issn     = {0167-6423},
  note     = {Special issue on Automated Verification of Critical Systems (AVoCS 2015)},
  abstract = {We propose a new numerical abstract domain for inferring linear invariants based on parallelotopes. The domain may encode any linear constraint, as the polyhedra abstract domain, while maintaining the efficiency of weakly relational abstract domains, such as intervals and octagons. We provide the full set of abstract operators, define a reduced product with intervals and present an experimental comparison with polyhedra and octagons. According to these experiments, the reduced product we propose is much more precise than both polyhedra and octagons in inferring interval constraints.},
  doi      = {https://doi.org/10.1016/j.scico.2017.05.011},
  keywords = {Static analysis, Abstract interpretation, Numerical abstract domain, Linear invariant, Parallelotopes},
  url      = {http://www.sciencedirect.com/science/article/pii/S0167642317301211},
}

@InProceedings{Mine2001,
  author    = {Min{\'e}, Antoine},
  title     = {A New Numerical Abstract Domain Based on Difference-Bound Matrices},
  booktitle = {Proceedings of the Second Symposium on Programs As Data Objects},
  year      = {2001},
  series    = {PADO '01},
  pages     = {155--172},
  address   = {London, UK, UK},
  publisher = {Springer-Verlag},
  acmid     = {668110},
  isbn      = {3-540-42068-1},
  numpages  = {18},
  url       = {http://dl.acm.org/citation.cfm?id=645774.668110},
}

@InProceedings{Mine2006b,
  author    = {Min{\'e}, Antoine},
  title     = {Symbolic Methods to Enhance the Precision of Numerical Abstract Domains},
  booktitle = {Verification, Model Checking, and Abstract Interpretation},
  year      = {2006},
  editor    = {Emerson, E. Allen and Namjoshi, Kedar S.},
  pages     = {348--363},
  address   = {Berlin, Heidelberg},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {We present lightweight and generic symbolic methods to improve the precision of numerical static analyses based on Abstract Interpretation. The main idea is to simplify numerical expressions before they are fed to abstract transfer functions. An important novelty is that these simplifications are performed on-the-fly, using information gathered dynamically by the analyzer.},
  isbn      = {978-3-540-31622-0},
}

@InProceedings{Sharma2017,
  author    = {Sharma, Tushar and Reps, Thomas},
  title     = {Sound Bit-Precise Numerical Domains},
  booktitle = {Verification, Model Checking, and Abstract Interpretation},
  year      = {2017},
  editor    = {Bouajjani, Ahmed and Monniaux, David},
  pages     = {500--520},
  address   = {Cham},
  publisher = {Springer International Publishing},
  abstract  = {This paper tackles the challenge of creating a numerical abstract domain that can identify affine-inequality invariants while handling overflow in arithmetic operations over bit-vector data-types. The paper describes the design and implementation of a class of new abstract domains, called the Bit-Vector-Sound, Finite-Disjunctive ({\$}{\$}{\backslash}textit{\{}BVSFD{\}}{\$}{\$}) domains. We introduce a framework that takes an abstract domain {\$}{\$}{\backslash}mathcal {\{}A{\}}{\$}{\$}that is sound with respect to mathematical integers and creates an abstract domain {\$}{\$}{\backslash}textit{\{}BVS{\}}({\backslash}mathcal {\{}A{\}}){\$}{\$}whose operations and abstract transformers are sound with respect to machine integers. We also describe how to create abstract transformers for {\$}{\$}{\backslash}textit{\{}BVS{\}}({\backslash}mathcal {\{}A{\}}){\$}{\$}that are sound with respect to machine arithmetic. The abstract transformers make use of an operation {\$}{\$}{\backslash}textit{\{}WRAP{\}}({\backslash}textit{\{}av{\}}, v){\$}{\$}---where {\$}{\$}{\backslash}textit{\{}av{\}} {\backslash}in {\backslash}mathcal {\{}A{\}}{\$}{\$}and v is a set of program variables---which performs wraparound in av for the variables in v.},
  isbn      = {978-3-319-52234-0},
}

@InProceedings{DeMoura2008,
  author    = {de Moura, Leonardo and Bjorner, Nikolaj},
  title     = {Z3: An Efficient SMT Solver},
  booktitle = {Tools and Algorithms for the Construction and Analysis of Systems},
  year      = {2008},
  editor    = {Ramakrishnan, C. R. and Rehof, Jakob},
  pages     = {337--340},
  address   = {Berlin, Heidelberg},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {Satisfiability Modulo Theories (SMT) problem is a decision problem for logical first order formulas with respect to combinations of background theories such as: arithmetic, bit-vectors, arrays, and uninterpreted functions. Z3 is a new and efficient SMT Solver freely available from Microsoft Research. It is used in various software verification and analysis applications.},
  isbn      = {978-3-540-78800-3},
}

@InProceedings{Barrett2011,
  author    = {Barrett, Clark and Conway, Christopher L. and Deters, Morgan and Hadarean, Liana and Jovanovi{\'{c}}, Dejan and King, Tim and Reynolds, Andrew and Tinelli, Cesare},
  title     = {CVC4},
  booktitle = {Computer Aided Verification},
  year      = {2011},
  editor    = {Gopalakrishnan, Ganesh and Qadeer, Shaz},
  pages     = {171--177},
  address   = {Berlin, Heidelberg},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {CVC4 is the latest version of the Cooperating Validity Checker. A joint project of NYU and U Iowa, CVC4 aims to support the useful feature set of CVC3 and SMT-LIBv2 while optimizing the design of the core system architecture and decision procedures to take advantage of recent engineering and algorithmic advances. CVC4 represents a completely new code base; it is a from-scratch rewrite of CVC3, and many subsystems have been completely redesigned. Additional decision procedures for CVC4 are currently under development, but for what it currently achieves, it is a lighter-weight and higher-performing tool than CVC3. We describe the system architecture, subsystems of note, and discuss some applications and continuing work.},
  isbn      = {978-3-642-22110-1},
}

@Article{Dutertre2006,
  author  = {Dutertre, Bruno and De Moura, Leonardo},
  title   = {The yices smt solver},
  journal = {Tool paper at http://yices. csl. sri. com/tool-paper. pdf},
  year    = {2006},
  volume  = {2},
  number  = {2},
  pages   = {1--2},
}

@InProceedings{Corzilius2015,
  author       = {Corzilius, Florian and Kremer, Gereon and Junges, Sebastian and Schupp, Stefan and {\'A}brah{\'a}m, Erika},
  title        = {SMT-RAT: An open source C++ toolbox for strategic and parallel SMT solving},
  booktitle    = {International Conference on Theory and Applications of Satisfiability Testing},
  year         = {2015},
  pages        = {360--368},
  organization = {Springer},
}

@InProceedings{Lauko2019Sym,
  author       = {Lauko, Henrich and {\v{S}}till, Vladim{\'\i}r and Ro{\v{c}}kai, Petr and Barnat, Ji{\v{r}}{\'\i}},
  title        = {Extending DIVINE with Symbolic Verification Using SMT},
  booktitle    = {International Conference on Tools and Algorithms for the Construction and Analysis of Systems},
  year         = {2019},
  pages        = {204--208},
  organization = {Springer},
}

@InProceedings{Lauko2018SymComp,
  author       = {Lauko, Henrich and Ro{\v{c}}kai, Petr and Barnat, Ji{\v{r}}{\'\i}},
  title        = {Symbolic computation via program transformation},
  booktitle    = {International Colloquium on Theoretical Aspects of Computing},
  year         = {2018},
  pages        = {313--332},
  organization = {Springer},
}

@PhdThesis{Mine2004Thesis,
  author = {Min{\'e}, Antoine},
  title  = {Weakly relational numerical abstract domains},
  year   = {2004},
}

@Article{File1999,
  author   = {Gilberto Filé and Francesco Ranzato},
  title    = {The powerset operator on abstract interpretations},
  journal  = {Theoretical Computer Science},
  year     = {1999},
  volume   = {222},
  number   = {1},
  pages    = {77 - 111},
  issn     = {0304-3975},
  abstract = {In the context of the standard Cousot and Cousot framework, refinement operators that systematically produce more precise abstract interpretations from simpler ones are useful. We present a theoretical study of one such operator: the powerset. For any given abstract interpretation, i.e. an abstract domain equipped with corresponding abstract operations, the powerset operator yields a new abstract interpretation, where the abstract domain is (very close to) the powerset of the original one and the operations are accordingly extended. It turns out that the refined powerset domain is able to represent in the best possible way the concrete disjunction. Conditions that guarantee the correctness of the powerset operator are given, and the relationship, with respect to the precision, between any abstract interpretation and its powerset is studied. The general theory is applied to the well-known abstract interpretation POS, typically used for ground-dependency analysis of logic languages. We show that the powerset P(POS) is strictly more precise than POS both at the domain and operations level. Furthermore, the standard bottom-up abstract semantics of logic programs based on POS and P(POS) are compared by exhibiting a completeness relationship between them, i.e. the first semantics can be obtained by abstracting back the second one.},
  doi      = {https://doi.org/10.1016/S0304-3975(98)00007-3},
  keywords = {Abstract interpretation, Powerset operator, Logic program ground-dependency analysis},
  url      = {http://www.sciencedirect.com/science/article/pii/S0304397598000073},
}

@Article{Giacobazzi2000,
  author     = {Giacobazzi, Roberto and Ranzato, Francesco and Scozzari, Francesca},
  title      = {Making Abstract Interpretations Complete},
  journal    = {J. ACM},
  year       = {2000},
  volume     = {47},
  number     = {2},
  pages      = {361--416},
  month      = mar,
  issn       = {0004-5411},
  acmid      = {333989},
  address    = {New York, NY, USA},
  doi        = {10.1145/333979.333989},
  issue_date = {March 2000},
  numpages   = {56},
  publisher  = {ACM},
  url        = {http://doi.acm.org/10.1145/333979.333989},
}

@InProceedings{Giacobazzi2001,
  author    = {Giacobazzi, Roberto and Quintarelli, Elisa},
  title     = {Incompleteness, Counterexamples, and Refinements in Abstract Model-Checking},
  booktitle = {Static Analysis},
  year      = {2001},
  editor    = {Cousot, Patrick},
  pages     = {356--373},
  address   = {Berlin, Heidelberg},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {In this paper we study the relation between the lack of completeness in abstract interpretation of model-checking and the structure of the counterexamples produced by a model-checker. We consider two dual forms of completeness of an abstract interpretation: Forward and backward completeness. They correspond respectively to the standard $\gamma$/$\alpha$ completeness of an abstract interpretation and can be related with each other by adjunction. We give a constructive characterization of Clarke et al.'s spurious counterexamples in terms of both forward and backward completeness of the underlying abstract interpretation. This result allows us to understand the structure of the counterexamples that can be removed by systematically refining abstract domains to achieve completeness with respect to a given operation. We apply our result to improve static program analysis by refining the model-checking of an abstract interpretation.},
  isbn      = {978-3-540-47764-8},
}

@InProceedings{Toubhans2013,
  author    = {Toubhans, Antoine and Chang, Bor-Yuh Evan and Rival, Xavier},
  title     = {Reduced Product Combination of Abstract Domains for Shapes},
  booktitle = {Verification, Model Checking, and Abstract Interpretation},
  year      = {2013},
  editor    = {Giacobazzi, Roberto and Berdine, Josh and Mastroeni, Isabella},
  pages     = {375--395},
  address   = {Berlin, Heidelberg},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {Real-world data structures are often enhanced with additional pointers capturing alternative paths through a basic inductive skeleton (e.g., back pointers, head pointers). From the static analysis point of view, we must obtain several interlocking shape invariants. At the same time, it is well understood in abstract interpretation design that supporting a separation of concerns is critically important to designing powerful static analyses. Such a separation of concerns is often obtained via a reduced product on a case-by-case basis. In this paper, we lift this idea to abstract domains for shape analyses, introducing a domain combination operator for memory abstractions. As an example, we present simultaneous separating shape graphs, a product construction that combines instances of separation logic-based shape domains. The key enabler for this construction is a static analysis on inductive data structure definitions to derive relations between the skeleton and the alternative paths. From the engineering standpoint, this construction allows each component to reason independently about different aspects of the data structure invariant and then separately exchange information via a reduction operator. From the usability standpoint, we enable describing a data structure invariant in terms of several inductive definitions that hold simultaneously.},
  isbn      = {978-3-642-35873-9},
}

@InProceedings{Cousot2007,
  author    = {Cousot, Patrick and Cousot, Radhia and Feret, J{\'e}r{\^o}me and Mauborgne, Laurent and Min{\'e}, Antoine and Monniaux, David and Rival, Xavier},
  title     = {Combination of Abstractions in the ASTR{\'E}E Static Analyzer},
  booktitle = {Advances in Computer Science - ASIAN 2006. Secure Software and Related Issues},
  year      = {2007},
  editor    = {Okada, Mitsu and Satoh, Ichiro},
  pages     = {272--300},
  address   = {Berlin, Heidelberg},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {We describe the structure of the abstract domains in the Astr{\'e}e static analyzer, their modular organization into a hierarchical network, their cooperation to over-approximate the conjunction/reduced product of different abstractions and to ensure termination using collaborative widenings and narrowings. This separation of the abstraction into a combination of cooperative abstract domains makes Astr{\'e}e extensible, an essential feature to cope with false alarms and ultimately provide sound formal verification of the absence of runtime errors in very large software.},
  isbn      = {978-3-540-77505-8},
}

@Article{Bouzaziz2012,
  author   = {Mehdi Bouaziz},
  title    = {TreeKs: A Functor to Make Numerical Abstract Domains Scalable},
  journal  = {Electronic Notes in Theoretical Computer Science},
  year     = {2012},
  volume   = {287},
  pages    = {41 - 52},
  issn     = {1571-0661},
  note     = {Proceedings of the Fourth International Workshop on Numerical and Symbolic Abstract Domains, NSAD 2012},
  abstract = {Relational numerical abstract domains do not scale up. To ensure a linear cost of abstract domains, abstract interpretation-based tools analyzing large programs generally split the set of variables into independent smaller sets, sometimes sharing some non-relational information. We present a way to gain precision by keeping fully expressive relations between the subsets of variables, whilst retaining a linear complexity ensuring scalability.},
  doi      = {https://doi.org/10.1016/j.entcs.2012.09.005},
  keywords = {Abstract interpretation, abstract numerical domains, weakly relational domains},
  url      = {http://www.sciencedirect.com/science/article/pii/S1571066112000576},
}

@Book{Muchnick1981,
  title     = {Program Flow Analysis: Theory and Application},
  publisher = {Prentice Hall Professional Technical Reference},
  year      = {1981},
  author    = {Muchnick, Steven S. and Jones, Neil D.},
  isbn      = {0137296819},
}

@Article{Bertrane2015,
  author     = {Bertrane, Julien and Cousot, Patrick and Cousot, Radhia and Feret, J{\'e}r\^{o}me and Mauborgne, Laurent and Min{\'e}, Antoine and Rival, Xavier},
  title      = {Static Analysis and Verification of Aerospace Software by Abstract Interpretation},
  journal    = {Found. Trends Program. Lang.},
  year       = {2015},
  volume     = {2},
  number     = {2-3},
  pages      = {71--190},
  month      = dec,
  issn       = {2325-1107},
  acmid      = {2900404},
  address    = {Hanover, MA, USA},
  doi        = {10.1561/2500000002},
  issue_date = {12 2015},
  numpages   = {120},
  publisher  = {Now Publishers Inc.},
  url        = {http://dx.doi.org/10.1561/2500000002},
}

@Article{Cousot2010,
  author  = {Bertrane, Julien and Cousot, Patrick and Cousot, Radhia and Feret, Jérôme and Mauborgne, Laurent and Miné, Antoine and Rival, Xavier},
  title   = {Static Analysis and Verification of Aerospace Software by Abstract Interpretation},
  journal = {American Institue of Aeronautics and Astronautics (AIAA) Infotech@Aerospace 2010},
  year    = {2010},
  volume  = {2},
  month   = {04},
  doi     = {10.2514/6.2010-3385},
}

@InBook{Cousot2010a,
  pages     = {72--95},
  title     = {A Scalable Segmented Decision Tree Abstract Domain},
  publisher = {Springer Berlin Heidelberg},
  year      = {2010},
  author    = {Cousot, Patrick and Cousot, Radhia and Mauborgne, Laurent},
  editor    = {Manna, Zohar and Peled, Doron A.},
  address   = {Berlin, Heidelberg},
  isbn      = {978-3-642-13754-9},
  abstract  = {The key to precision and scalability in all formal methods for static program analysis and verification is the handling of disjunctions arising in relational analyses, the flow-sensitive traversal of conditionals and loops, the context-sensitive inter-procedural calls, the interleaving of concurrent threads, etc. Explicit case enumeration immediately yields to combinatorial explosion. The art of scalable static analysis is therefore to abstract disjunctions to minimize cost while preserving weak forms of disjunctions for expressivity.},
  booktitle = {Time for Verification: Essays in Memory of Amir Pnueli},
  doi       = {10.1007/978-3-642-13754-9_5},
  url       = {https://doi.org/10.1007/978-3-642-13754-9_5},
}

@InProceedings{Urban2010,
  author    = {Urban, Caterina and Min{\'e}, Antoine},
  title     = {A Decision Tree Abstract Domain for Proving Conditional Termination},
  booktitle = {Static Analysis},
  year      = {2014},
  editor    = {M{\"u}ller-Olm, Markus and Seidl, Helmut},
  pages     = {302--318},
  address   = {Cham},
  publisher = {Springer International Publishing},
  abstract  = {We present a new parameterized abstract domain able to refine existing numerical abstract domains with finite disjunctions. The elements of the abstract domain are decision trees where the decision nodes are labeled with linear constraints, and the leaf nodes belong to a numerical abstract domain.},
  isbn      = {978-3-319-10936-7},
}

@InProceedings{Bagnara2004,
  author    = {Bagnara, Roberto and Hill, Patricia M. and Zaffanella, Enea},
  title     = {Widening Operators for Powerset Domains},
  booktitle = {Verification, Model Checking, and Abstract Interpretation},
  year      = {2004},
  editor    = {Steffen, Bernhard and Levi, Giorgio},
  pages     = {135--148},
  address   = {Berlin, Heidelberg},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {The finite powerset construction upgrades an abstract domain by allowing for the representation of finite disjunctions of its elements. In this paper we define two generic widening operators for the finite powerset abstract domain. Both widenings are obtained by lifting any widening operator defined on the base-level abstract domain and are parametric with respect to the specification of a few additional operators. We illustrate the proposed techniques by instantiating our widenings on powersets of convex polyhedra, a domain for which no non-trivial widening operator was previously known.},
  isbn      = {978-3-540-24622-0},
}

@Article{Bagnara2010,
  author   = {Roberto Bagnara and Patricia M. Hill and Enea Zaffanella},
  title    = {Exact join detection for convex polyhedra and other numerical abstractions},
  journal  = {Computational Geometry},
  year     = {2010},
  volume   = {43},
  number   = {5},
  pages    = {453 - 473},
  issn     = {0925-7721},
  doi      = {https://doi.org/10.1016/j.comgeo.2009.09.002},
  keywords = {Polyhedron, Union, Convexity, Abstract interpretation, Numerical abstraction, Powerset domain},
  url      = {http://www.sciencedirect.com/science/article/pii/S0925772109001357},
}

@InProceedings{Mrazek2017,
  author    = {Mr\'{a}zek, Jan and Jon\'{a}\v{s}, Martin and \v{S}till, Vladim\'{\i}r and Lauko, Henrich and Barnat, Ji\v{r}\'{\i}},
  title     = {Optimizing and Caching SMT Queries in SymDIVINE},
  booktitle = {Proceedings, Part II, of the 23rd International Conference on Tools and Algorithms for the Construction and Analysis of Systems - Volume 10206},
  year      = {2017},
  pages     = {390--393},
  address   = {Berlin, Heidelberg},
  publisher = {Springer-Verlag},
  acmid     = {3080490},
  doi       = {10.1007/978-3-662-54580-5_29},
  isbn      = {978-3-662-54579-9},
  numpages  = {4},
  url       = {https://doi.org/10.1007/978-3-662-54580-5_29},
}

@InProceedings{Graf1997,
  author    = {Graf, Susanne and Saidi, Hassen},
  title     = {Construction of abstract state graphs with PVS},
  booktitle = {Computer Aided Verification},
  year      = {1997},
  editor    = {Grumberg, Orna},
  pages     = {72--83},
  address   = {Berlin, Heidelberg},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {In this paper, we propose a method for the automatic construction of an abstract state graph of an arbitrary system using the Pvs theorem prover.},
  isbn      = {978-3-540-69195-2},
}

@InProceedings{Ball2001,
  author       = {Ball, Thomas and Majumdar, Rupak and Millstein, Todd and Rajamani, Sriram K},
  title        = {Automatic predicate abstraction of C programs},
  booktitle    = {ACM SIGPLAN Notices},
  year         = {2001},
  volume       = {36},
  number       = {5},
  pages        = {203--213},
  organization = {Citeseer},
}

@Article{Bjorner1997,
  author    = {Bj{\o}rner, Nikolaj and Browne, Anca and Manna, Zohar},
  title     = {Automatic generation of invariants and intermediate assertions},
  journal   = {Theoretical Computer Science},
  year      = {1997},
  volume    = {173},
  number    = {1},
  pages     = {49--87},
  publisher = {Elsevier},
}

@InProceedings{Mycroft1993,
  author       = {Mycroft, Alan},
  title        = {Completeness and predicate-based abstract interpretation},
  booktitle    = {Proceedings of the 1993 ACM SIGPLAN symposium on Partial evaluation and semantics-based program manipulation},
  year         = {1993},
  pages        = {179--185},
  organization = {ACM},
}

@InCollection{Cousot2003,
  author    = {Cousot, Patrick},
  title     = {Verification by abstract interpretation},
  booktitle = {Verification: Theory and Practice},
  publisher = {Springer},
  year      = {2003},
  pages     = {243--268},
}

@InProceedings{Flanagan2002,
  author       = {Flanagan, Cormac and Qadeer, Shaz},
  title        = {Predicate abstraction for software verification},
  booktitle    = {ACM SIGPLAN Notices},
  year         = {2002},
  volume       = {37},
  number       = {1},
  pages        = {191--202},
  organization = {ACM},
}

@Article{Cimatti2016,
  author   = {Cimatti, Alessandro and Griggio, Alberto and Mover, Sergio and Tonetta, Stefano},
  title    = {Infinite-state invariant checking with IC3 and predicate abstraction},
  journal  = {Formal Methods in System Design},
  year     = {2016},
  volume   = {49},
  number   = {3},
  pages    = {190--218},
  month    = {Dec},
  issn     = {1572-8102},
  abstract = {We address the problem of verifying invariant properties on infinite-state systems. We present a novel approach, IC3ia, for generalizing the IC3 invariant checking algorithm from finite-state to infinite-state transition systems, expressed over some background theories. The procedure is based on a tight integration of IC3 with Implicit Abstraction, a form of predicate abstraction that expresses abstract paths without computing explicitly the abstract system. In this scenario, IC3 operates only at the Boolean level of the abstract state space, discovering inductive clauses over the abstraction predicates. Theory reasoning is confined within the underlying SMT solver, and applied transparently when performing satisfiability checks. When the current abstraction allows for a spurious counterexample, it is refined by discovering and adding a sufficient set of new predicates. Importantly, this can be done in a completely incremental manner, without discarding the clauses found in the previous search. The proposed approach has two key advantages. First, unlike previous SMT generalizations of IC3, it allows to handle a wide range of background theories without relying on ad-hoc extensions, such as quantifier elimination or theory-specific clause generalization procedures, which might not always be available and are often highly inefficient. Second, compared to a direct exploration of the concrete transition system, the use of abstraction gives a significant performance improvement, as our experiments demonstrate.},
  day      = {01},
  doi      = {10.1007/s10703-016-0257-4},
  url      = {https://doi.org/10.1007/s10703-016-0257-4},
}

@InProceedings{Gange2013,
  author       = {Gange, Graeme and Navas, Jorge A and Schachte, Peter and S{\o}ndergaard, Harald and Stuckey, Peter J},
  title        = {Abstract interpretation over non-lattice abstract domains},
  booktitle    = {International Static Analysis Symposium},
  year         = {2013},
  pages        = {6--24},
  organization = {Springer},
}

@InProceedings{Gange2016,
  author       = {Gange, Graeme and Navas, Jorge A and Schachte, Peter and S{\o}ndergaard, Harald and Stuckey, Peter J},
  title        = {An abstract domain of uninterpreted functions},
  booktitle    = {International Conference on Verification, Model Checking, and Abstract Interpretation},
  year         = {2016},
  pages        = {85--103},
  organization = {Springer},
}

@InProceedings{Chang2005,
  author       = {Chang, Bor-Yuh Evan and Leino, K Rustan M},
  title        = {Abstract interpretation with alien expressions and heap structures},
  booktitle    = {International Workshop on Verification, Model Checking, and Abstract Interpretation},
  year         = {2005},
  pages        = {147--163},
  organization = {Springer},
}

@InProceedings{Venet2012,
  author       = {Venet, Arnaud J},
  title        = {The gauge domain: scalable analysis of linear inequality invariants},
  booktitle    = {International Conference on Computer Aided Verification},
  year         = {2012},
  pages        = {139--154},
  organization = {Springer},
}

@InProceedings{Bugariu2018,
  author       = {Bugariu, Alexandra and W{\"u}stholz, Valentin and Christakis, Maria and M{\"u}ller, Peter},
  title        = {Automatically testing implementations of numerical abstract domains},
  booktitle    = {Proceedings of the 33rd ACM/IEEE International Conference on Automated Software Engineering},
  year         = {2018},
  pages        = {768--778},
  organization = {ACM},
}

@InProceedings{Cornish2015,
  author    = {Cornish, J. Robert M. and Gange, Graeme and Navas, Jorge A. and Schachte, Peter and S{\o}ndergaard, Harald and Stuckey, Peter J.},
  title     = {Analyzing Array Manipulating Programs by Program Transformation},
  booktitle = {Logic-Based Program Synthesis and Transformation},
  year      = {2015},
  editor    = {Proietti, Maurizio and Seki, Hirohisa},
  pages     = {3--20},
  address   = {Cham},
  publisher = {Springer International Publishing},
  abstract  = {We explore a transformational approach to the problem of verifying simple array-manipulating programs. Traditionally, verification of such programs requires intricate analysis machinery to reason with universally quantified statements about symbolic array segments, such as ``every data item stored in the segment A[i] to A[j] is equal to the corresponding item stored in the segment B[i] to B[j].'' We define a simple abstract machine which allows for set-valued variables and we show how to translate programs with array operations to array-free code for this machine. For the purpose of program analysis, the translated program remains faithful to the semantics of array manipulation. Based on our implementation in LLVM, we evaluate the approach with respect to its ability to extract useful invariants and the cost in terms of code size.},
  isbn      = {978-3-319-17822-6},
}

@Article{Gopan2005,
  author    = {Gopan, Denis and Reps, Thomas and Sagiv, Mooly},
  title     = {A framework for numeric analysis of array operations},
  journal   = {ACM SIGPLAN Notices},
  year      = {2005},
  volume    = {40},
  number    = {1},
  pages     = {338--350},
  publisher = {ACM},
}

@Article{Cousot2011p,
  author    = {Cousot, Patrick and Cousot, Radhia and Logozzo, Francesco},
  title     = {A parametric segmentation functor for fully automatic and scalable array content analysis},
  journal   = {ACM SIGPLAN Notices},
  year      = {2011},
  volume    = {46},
  number    = {1},
  pages     = {105--118},
  publisher = {ACM},
}

@InProceedings{Halbwachs2008,
  author       = {Halbwachs, Nicolas and P{\'e}ron, Mathias},
  title        = {Discovering properties about arrays in simple programs},
  booktitle    = {ACM SIGPLAN Notices},
  year         = {2008},
  volume       = {43},
  number       = {6},
  pages        = {339--348},
  organization = {ACM},
}

@InProceedings{Gulwani2008,
  author       = {Gulwani, Sumit and McCloskey, Bill and Tiwari, Ashish},
  title        = {Lifting abstract interpreters to quantified logical domains},
  booktitle    = {ACM SIGPLAN Notices},
  year         = {2008},
  volume       = {43},
  number       = {1},
  pages        = {235--246},
  organization = {ACM},
}

@InProceedings{Alberti2012,
  author       = {Alberti, Francesco and Bruttomesso, Roberto and Ghilardi, Silvio and Ranise, Silvio and Sharygina, Natasha},
  title        = {Lazy abstraction with interpolants for arrays},
  booktitle    = {International Conference on Logic for Programming Artificial Intelligence and Reasoning},
  year         = {2012},
  pages        = {46--61},
  organization = {Springer},
}

@InProceedings{Kovacs2009,
  author       = {Kov{\'a}cs, Laura and Voronkov, Andrei},
  title        = {Finding loop invariants for programs over arrays using a theorem prover},
  booktitle    = {International Conference on Fundamental Approaches to Software Engineering},
  year         = {2009},
  pages        = {470--485},
  organization = {Springer},
}

@InProceedings{Seghir2009,
  author       = {Seghir, Mohamed Nassim and Podelski, Andreas and Wies, Thomas},
  title        = {Abstraction refinement for quantified array assertions},
  booktitle    = {International Static Analysis Symposium},
  year         = {2009},
  pages        = {3--18},
  organization = {Springer},
}

@InProceedings{Christensen2003,
  author       = {Christensen, Aske Simon and M{\o}ller, Anders and Schwartzbach, Michael I},
  title        = {Precise analysis of string expressions},
  booktitle    = {International Static Analysis Symposium},
  year         = {2003},
  pages        = {1--18},
  organization = {Springer},
}

@InProceedings{Costantini2011,
  author       = {Costantini, Giulia and Ferrara, Pietro and Cortesi, Agostino},
  title        = {Static analysis of string values},
  booktitle    = {International Conference on Formal Engineering Methods},
  year         = {2011},
  pages        = {505--521},
  organization = {Springer},
}

@Article{Halder2012,
  author    = {Halder, Raju and Cortesi, Agostino},
  title     = {Abstract interpretation of database query languages},
  journal   = {Computer Languages, Systems \& Structures},
  year      = {2012},
  volume    = {38},
  number    = {2},
  pages     = {123--157},
  publisher = {Elsevier},
}

@TechReport{Sharma2013,
  author      = {Sharma, Tushar and Thakur, Aditya and Reps, Thomas},
  title       = {An abstract domain for bit-vector inequalities},
  institution = {Computer Science Department, University of Wisconsin, Madison},
  year        = {2013},
}

@InProceedings{Reps2010,
  author       = {Reps, Thomas and Lim, Junghee and Thakur, Aditya and Balakrishnan, Gogul and Lal, Akash},
  title        = {There’s plenty of room at the bottom: Analyzing and verifying machine code},
  booktitle    = {International Conference on Computer Aided Verification},
  year         = {2010},
  pages        = {41--56},
  organization = {Springer},
}

@InProceedings{Thakur2012,
  author       = {Thakur, Aditya and Reps, Thomas},
  title        = {A method for symbolic computation of abstract operations},
  booktitle    = {International Conference on Computer Aided Verification},
  year         = {2012},
  pages        = {174--192},
  organization = {Springer},
}

@InProceedings{Dan2013,
  author       = {Dan, Andrei Marian and Meshman, Yuri and Vechev, Martin and Yahav, Eran},
  title        = {Predicate abstraction for relaxed memory models},
  booktitle    = {International Static Analysis Symposium},
  year         = {2013},
  pages        = {84--104},
  organization = {Springer},
}

@InProceedings{Reynolds2002,
  author       = {Reynolds, John C},
  title        = {Separation logic: A logic for shared mutable data structures},
  booktitle    = {Proceedings 17th Annual IEEE Symposium on Logic in Computer Science},
  year         = {2002},
  pages        = {55--74},
  organization = {IEEE},
}

@InProceedings{Distefano2006,
  author       = {Distefano, Dino and O’hearn, Peter W and Yang, Hongseok},
  title        = {A local shape analysis based on separation logic},
  booktitle    = {International Conference on Tools and Algorithms for the Construction and Analysis of Systems},
  year         = {2006},
  pages        = {287--302},
  organization = {Springer},
}

@InProceedings{Chang2008,
  author       = {Chang, Bor-Yuh Evan and Rival, Xavier},
  title        = {Relational inductive shape analysis},
  booktitle    = {ACM SIGPLAN Notices},
  year         = {2008},
  volume       = {43},
  number       = {1},
  pages        = {247--260},
  organization = {ACM},
}

@InProceedings{Magill2010,
  author       = {Magill, Stephen and Tsai, Ming-Hsien and Lee, Peter and Tsay, Yih-Kuen},
  title        = {Automatic numeric abstractions for heap-manipulating programs},
  booktitle    = {ACM Sigplan Notices},
  year         = {2010},
  volume       = {45},
  number       = {1},
  pages        = {211--222},
  organization = {ACM},
}

@InProceedings{Nanevski2010,
  author    = {Nanevski, Aleksandar and Vafeiadis, Viktor and Berdine, Josh},
  title     = {Structuring the Verification of Heap-manipulating Programs},
  booktitle = {Proceedings of the 37th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  year      = {2010},
  series    = {POPL '10},
  pages     = {261--274},
  address   = {New York, NY, USA},
  publisher = {ACM},
  acmid     = {1706331},
  doi       = {10.1145/1706299.1706331},
  isbn      = {978-1-60558-479-9},
  keywords  = {hoare logic, monads, separation logic, type theory},
  location  = {Madrid, Spain},
  numpages  = {14},
  url       = {http://doi.acm.org/10.1145/1706299.1706331},
}

@InProceedings{Malik2018,
  author    = {V. {Malík} and M. {Hruska} and P. {Schrammel} and T. {Vojnar}},
  title     = {Template-Based Verification of Heap-Manipulating Programs},
  booktitle = {2018 Formal Methods in Computer Aided Design (FMCAD)},
  year      = {2018},
  pages     = {1-9},
  month     = {Oct},
  doi       = {10.23919/FMCAD.2018.8603009},
  keywords  = {data structures;inference mechanisms;program verification;reachability analysis;template-based verification;abstract template domain;SMT solver;automatic invariant inference;shape analysis;heap-manipulating programs;unbounded data structures;combined reasoning;Software Verification Competition;2LS framework;dynamic data structures;reachability properties;memory safety;Data structures;Shape;Tools;Cognition;Dynamic scheduling;Reactive power;Software},
}

@InProceedings{Jaffar2013,
  author    = {Jaffar, Joxan and Murali, Vijayaraghavan and Navas, Jorge A},
  title     = {Boosting concolic testing via interpolation.},
  booktitle = {ESEC/SIGSOFT FSE},
  year      = {2013},
  pages     = {48--58},
}

@InProceedings{Gurfinkel2015,
  author       = {Gurfinkel, Arie and Kahsai, Temesghen and Komuravelli, Anvesh and Navas, Jorge A},
  title        = {The SeaHorn verification framework},
  booktitle    = {International Conference on Computer Aided Verification},
  year         = {2015},
  pages        = {343--361},
  organization = {Springer},
}

@InProceedings{Journault2019,
  author    = {Journault, Matthieu and Min{\'e}, Antoine and Ouadjaout, Abdelraouf},
  title     = {An Abstract Domain for Trees with Numeric Relations},
  booktitle = {Programming Languages and Systems},
  year      = {2019},
  editor    = {Caires, Lu{\'i}s},
  pages     = {724--751},
  address   = {Cham},
  publisher = {Springer International Publishing},
  abstract  = {We present an abstract domain able to infer invariants on programs manipulating trees. Trees considered in the article are defined over a finite alphabet and can contain unbounded numeric values at their leaves. Our domain can infer the possible shapes of the tree values of each variable and find numeric relations between: the values at the leaves as well as the size and depth of the tree values of different variables. The abstract domain is described as a product of (1) a symbolic domain based on a tree automata representation and (2) a numerical domain lifted, for the occasion, to describe numerical maps with potentially infinite and heterogeneous definition set. In addition to abstract set operations and widening we define concrete and abstract transformers on these environments. We present possible applications, such as the ability to describe memory zones, or track symbolic equalities between program variables. We implemented our domain in a static analysis platform and present preliminary results analyzing a tree-manipulating toy-language.},
  isbn      = {978-3-030-17184-1},
}

@InProceedings{McMillan2006,
  author    = {McMillan, Kenneth L.},
  title     = {Lazy Abstraction with Interpolants},
  booktitle = {Computer Aided Verification},
  year      = {2006},
  editor    = {Ball, Thomas and Jones, Robert B.},
  pages     = {123--136},
  address   = {Berlin, Heidelberg},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {We describe a model checker for infinite-state sequential programs, based on Craig interpolation and the lazy abstraction paradigm. On device driver benchmarks, we observe a speedup of up to two orders of magnitude relative to a similar tool using predicate abstraction.},
  isbn      = {978-3-540-37411-4},
}

@InProceedings{Hyvarinen2017,
  author = {Hyvarinen, Antti and Asadi, Sepideh and Even Mendoza, Karine and Fedyukovich, Grigory and Chockler, Hana and Sharygina, Natasha},
  title  = {Theory Refinement for Program Verification},
  year   = {2017},
  month  = {09},
  doi    = {10.1007/978-3-319-66263-3_22},
}

@InProceedings{McMillan2018,
  author    = {McMillan, Kenneth L.},
  title     = {Eager Abstraction for Symbolic Model Checking},
  booktitle = {Computer Aided Verification},
  year      = {2018},
  editor    = {Chockler, Hana and Weissenbacher, Georg},
  pages     = {191--208},
  address   = {Cham},
  publisher = {Springer International Publishing},
  abstract  = {We introduce a method of abstraction from infinite-state to finite-state model checking based on eager theory explication and evaluate the method in a collection of case studies.},
  isbn      = {978-3-319-96145-3},
}

@InProceedings{Qian2004,
  author    = {Qian, Kairong and Nymeyer, Albert},
  title     = {Abstraction-Based Model Checking Using Heuristical Refinement},
  booktitle = {Automated Technology for Verification and Analysis},
  year      = {2004},
  editor    = {Wang, Farn},
  pages     = {165--178},
  address   = {Berlin, Heidelberg},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {The major challenge in model checking for more than two decades has been dealing with the very large number of states that typify industrial systems. Abstraction-based methods have been particularly successful in this regard. Heuristic-based methods that use domain knowledge to guide a model checker can also be effective in dealing with large systems. In this work, we present an abstraction and heuristic-based model checking algorithm (called Static Abstraction Guided model checking) that verifies the safety properties of a system. Unlike other abstraction-based approaches, this work proposes a model-checking algorithm that uses a sequence of abstract models as input, and a method to refine counterexamples to determine whether they are spurious or real. During this refinement, abstract models in the sequence are used as heuristics to guide the model checker. This tight integration of abstraction and guidance is doubly effective in countering state explosion. This paper deals with the theoretical and algorithmic aspects of the approach only.},
  isbn      = {978-3-540-30476-0},
}

@InProceedings{Pelnek2006,
  author = {Radek Pel{\'a}nek},
  title  = {Reduction and Abstraction Techniques for Model Checking},
  year   = {2006},
}

@Article{Mauborgne2000,
  author  = {Mauborgne, Laurent},
  title   = {An incremental unique representation for regular trees},
  journal = {Nord. J. Comput.},
  year    = {2000},
  volume  = {7},
  number  = {4},
  pages   = {290--311},
}

@InProceedings{Cousot1977static,
  author       = {Cousot, Patrick and Cousot, Radhia},
  title        = {Static determination of dynamic properties of generalized type unions},
  booktitle    = {ACM SIGPLAN Notices},
  year         = {1977},
  volume       = {12},
  number       = {3},
  pages        = {77--94},
  organization = {ACM},
}

@InProceedings{Cousot1977rec,
  author       = {Cousot, Patrick and Cousot, Radhia},
  title        = {Static determination of dynamic properties of recursive procedures},
  booktitle    = {IFIP Conference on Formal Description of Programming Concepts, St. Andrews, NB, Canada},
  year         = {1977},
  pages        = {237--277},
  organization = {North-Holland Publishing Company},
}

@InCollection{Reps2002,
  author    = {Reps, Thomas and Sagiv, Mooly and Wilhelm, Reinhard},
  title     = {Shape analysis and applications},
  booktitle = {The Compiler Design Handbook},
  publisher = {CRC Press},
  year      = {2002},
  pages     = {179--221},
}

@Article{Mathur2019,
  author    = {Mathur, Umang and Madhusudan, P and Viswanathan, Mahesh},
  title     = {Decidable verification of uninterpreted programs},
  journal   = {Proceedings of the ACM on Programming Languages},
  year      = {2019},
  volume    = {3},
  number    = {POPL},
  pages     = {46},
  publisher = {ACM},
}

@InProceedings{Clarke2000,
  author    = {Clarke, Edmund and Grumberg, Orna and Jha, Somesh and Lu, Yuan and Veith, Helmut},
  title     = {Counterexample-Guided Abstraction Refinement},
  booktitle = {Computer Aided Verification},
  year      = {2000},
  editor    = {Emerson, E. Allen and Sistla, Aravinda Prasad},
  pages     = {154--169},
  address   = {Berlin, Heidelberg},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {We present an automatic iterative abstraction-refinement methodology in which the initial abstract model is generated by an automatic analysis of the control structures in the program to be verified. Abstract models may admit erroneous (or ``spurious'') counterexamples. We devise new symbolic techniques which analyze such counterexamples and refine the abstract model correspondingly. The refinement algorithm keeps the size of the abstract state space small due to the use of abstraction functions which distinguish many degrees of abstraction for each program variable. We describe an implementation of our methodology in NuSMV. Practical experiments including a large Fujitsu IP core design with about 500 latches and 10000 lines of SMV code confirm the effectiveness of our approach.},
  isbn      = {978-3-540-45047-4},
}

@InProceedings{Jhala2006,
  author    = {Jhala, Ranjit and McMillan, K. L.},
  title     = {A Practical and Complete Approach to Predicate Refinement},
  booktitle = {Tools and Algorithms for the Construction and Analysis of Systems},
  year      = {2006},
  editor    = {Hermanns, Holger and Palsberg, Jens},
  pages     = {459--473},
  address   = {Berlin, Heidelberg},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {Predicate abstraction is a method of synthesizing the strongest inductive invariant of a system expressible as a Boolean combination of a given set of atomic predicates. A predicate selection method can be said to be complete for a given theory if it is guaranteed to eventually find atomic predicates sufficient to prove a given property, when such exist. Current heuristics are incomplete, and often diverge on simple examples. We present a practical method of predicate selection that is complete in the above sense. The method is based on interpolation and uses a ``split prover'', somewhat in the style of structure-based provers used in artificial intelligence. We show that it allows the verification of a variety of simple programs that cannot be verified by existing software model checkers.},
  isbn      = {978-3-540-33057-8},
}

@InProceedings{Henzinger2003,
  author    = {Henzinger, Thomas A. and Jhala, Ranjit and Majumdar, Rupak and Sutre, Gr{\'e}goire},
  title     = {Software Verification with BLAST},
  booktitle = {Model Checking Software},
  year      = {2003},
  editor    = {Ball, Thomas and Rajamani, Sriram K.},
  pages     = {235--239},
  address   = {Berlin, Heidelberg},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {Blast (the Berkeley Lazy Abstraction Software verification Tool) is a verification system for checking safety properties of C programs using automatic property-driven construction and model checking of software abstractions. Blast implements an abstract-model check-refine loop to check for reachability of a specified label in the program. The abstract model is built on the fly using predicate abstraction. This model is then checked for reachability. If there is no (abstract) path to the specified error label, Blast reports that the system is safe and produces a succinct proof. Otherwise, it checks if the path is feasible using symbolic execution of the program. If the path is feasible, Blast outputs the path as an error trace, otherwise, it uses the infeasibility of the path to refine the abstract model. Blast short-circuits the loop from abstraction to verification to refinement, integrating the three steps tightly through ``lazy abstraction'' [5]. This integration can offer significant advantages in performance by avoiding the repetition of work from one iteration of the loop to the next.},
  isbn      = {978-3-540-44829-7},
}

@InProceedings{Beyer2005checking,
  author       = {Beyer, Dirk and Henzinger, Thomas A and Jhala, Ranjit and Majumdar, Rupak},
  title        = {Checking memory safety with Blast},
  booktitle    = {International Conference on Fundamental Approaches to Software Engineering},
  year         = {2005},
  pages        = {2--18},
  organization = {Springer},
}

@InProceedings{Clarke2005satabs,
  author       = {Clarke, Edmund and Kroening, Daniel and Sharygina, Natasha and Yorav, Karen},
  title        = {SATABS: SAT-based predicate abstraction for ANSI-C},
  booktitle    = {International Conference on Tools and Algorithms for the Construction and Analysis of Systems},
  year         = {2005},
  pages        = {570--574},
  organization = {Springer},
}

@InProceedings{Beyer2013,
  author    = {Beyer, Dirk and L{\"o}we, Stefan},
  title     = {Explicit-State Software Model Checking Based on CEGAR and Interpolation},
  booktitle = {Fundamental Approaches to Software Engineering},
  year      = {2013},
  editor    = {Cortellessa, Vittorio and Varr{\'o}, D{\'a}niel},
  pages     = {146--162},
  address   = {Berlin, Heidelberg},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {Abstraction, counterexample-guided refinement, and interpolation are techniques that are essential to the success of predicate-based program analysis. These techniques have not yet been applied together to explicit-value program analysis. We present an approach that integrates abstraction and interpolationbased refinement into an explicit-value analysis, i.e., a program analysis that tracks explicit values for a specified set of variables (the precision). The algorithm uses an abstract reachability graph as central data structure and a path-sensitive dynamic approach for precision adjustment. We evaluate our algorithm on the benchmark set of the Competition on Software Verification 2012 (SV-COMP'12) to show that our new approach is highly competitive. We also show that combining our new approach with an auxiliary predicate analysis scores significantly higher than the SV-COMP'12 winner.},
  isbn      = {978-3-642-37057-1},
}

@InProceedings{Beyer2008program,
  author       = {Beyer, Dirk and Henzinger, Thomas A and Th{\'e}oduloz, Gr{\'e}gory},
  title        = {Program analysis with dynamic precision adjustment},
  booktitle    = {2008 23rd IEEE/ACM International Conference on Automated Software Engineering},
  year         = {2008},
  pages        = {29--38},
  organization = {IEEE},
}

@InProceedings{Gulavani2008,
  author       = {Gulavani, Bhargav S and Chakraborty, Supratik and Nori, Aditya V and Rajamani, Sriram K},
  title        = {Automatically refining abstract interpretations},
  booktitle    = {International Conference on Tools and Algorithms for the Construction and Analysis of Systems},
  year         = {2008},
  pages        = {443--458},
  organization = {Springer},
}

@InProceedings{Albarghouthi2012,
  author       = {Albarghouthi, Aws and Gurfinkel, Arie and Chechik, Marsha},
  title        = {Craig interpretation},
  booktitle    = {International Static Analysis Symposium},
  year         = {2012},
  pages        = {300--316},
  organization = {Springer},
}

@InProceedings{Henzinger2004abstractions,
  author       = {Henzinger, Thomas A and Jhala, Ranjit and Majumdar, Rupak and McMillan, Kenneth L},
  title        = {Abstractions from proofs},
  booktitle    = {ACM SIGPLAN Notices},
  year         = {2004},
  volume       = {39},
  number       = {1},
  pages        = {232--244},
  organization = {ACM},
}

@InProceedings{Mcmillan2003interpolation,
  author       = {McMillan, Kenneth L},
  title        = {Interpolation and SAT-based model checking},
  booktitle    = {International Conference on Computer Aided Verification},
  year         = {2003},
  pages        = {1--13},
  organization = {Springer},
}

@InProceedings{Jhala2007array,
  author       = {Jhala, Ranjit and McMillan, Kenneth L},
  title        = {Array abstractions from proofs},
  booktitle    = {International Conference on Computer Aided Verification},
  year         = {2007},
  pages        = {193--206},
  organization = {Springer},
}

@InProceedings{Alberti2012b,
  author    = {Alberti, Francesco and Bruttomesso, Roberto and Ghilardi, Silvio and Ranise, Silvio and Sharygina, Natasha},
  title     = {SAFARI: SMT-Based Abstraction for Arrays with Interpolants},
  booktitle = {Computer Aided Verification},
  year      = {2012},
  editor    = {Madhusudan, P. and Seshia, Sanjit A.},
  pages     = {679--685},
  address   = {Berlin, Heidelberg},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {We present SAFARI, a model checker designed to prove (possibly universally quantified) safety properties of imperative programs with arrays of unknown length. SAFARI is based on an extension of lazy abstraction capable of handling existentially quantified formul{\ae} for symbolically representing states. A heuristics, called term abstraction, favors the convergence of the tool by ``tuning'' interpolants and guessing additional quantified variables of invariants to prune the search space efficiently.},
  isbn      = {978-3-642-31424-7},
}

@Article{Cadar2013symbolic,
  author  = {Cadar, Cristian and Sen, Koushik},
  title   = {Symbolic execution for software testing: three decades later.},
  journal = {Commun. ACM},
  year    = {2013},
  volume  = {56},
  number  = {2},
  pages   = {82--90},
}

@Article{Biere2003bounded,
  author  = {Biere, Armin and Cimatti, Alessandro and Clarke, Edmund M and Strichman, Ofer and Zhu, Yunshan and others},
  title   = {Bounded model checking.},
  journal = {Advances in computers},
  year    = {2003},
  volume  = {58},
  number  = {11},
  pages   = {117--148},
}

@Article{Baldoni2018survey,
  author    = {Baldoni, Roberto and Coppa, Emilio and D’elia, Daniele Cono and Demetrescu, Camil and Finocchi, Irene},
  title     = {A survey of symbolic execution techniques},
  journal   = {ACM Computing Surveys (CSUR)},
  year      = {2018},
  volume    = {51},
  number    = {3},
  pages     = {50},
  publisher = {ACM},
}

@InProceedings{Cadar2008klee,
  author    = {Cadar, Cristian and Dunbar, Daniel and Engler, Dawson R and others},
  title     = {KLEE: Unassisted and Automatic Generation of High-Coverage Tests for Complex Systems Programs.},
  booktitle = {OSDI},
  year      = {2008},
  volume    = {8},
  pages     = {209--224},
}

@InProceedings{Beyer2018Klee,
  author    = {Beyer, Dirk and Lemberger, Thomas},
  title     = {CPA-SymExec: Efficient Symbolic Execution in CPAchecker},
  booktitle = {Proceedings of the 33rd ACM/IEEE International Conference on Automated Software Engineering},
  year      = {2018},
  series    = {ASE 2018},
  pages     = {900--903},
  address   = {New York, NY, USA},
  publisher = {ACM},
  acmid     = {3240478},
  doi       = {10.1145/3238147.3240478},
  isbn      = {978-1-4503-5937-5},
  keywords  = {Program Analysis, Symbolic Execution, Test-Case Generation},
  location  = {Montpellier, France},
  numpages  = {4},
  url       = {http://doi.acm.org/10.1145/3238147.3240478},
}

@InProceedings{Chalupa2018,
  author       = {Chalupa, Marek and Vitovsk{\'a}, Martina and Strej{\v{c}}ek, Jan},
  title        = {SYMBIOTIC 5: boosted instrumentation},
  booktitle    = {International Conference on Tools and Algorithms for the Construction and Analysis of Systems},
  year         = {2018},
  pages        = {442--446},
  organization = {Springer},
}

@InProceedings{Chen2018,
  author    = {Chen, Bo and Havlicek, Christopher and Yang, Zhenkun and Cong, Kai and Kannavara, Raghudeep and Xie, Fei},
  title     = {CRETE: A Versatile Binary-Level Concolic Testing Framework},
  booktitle = {Fundamental Approaches to Software Engineering},
  year      = {2018},
  editor    = {Russo, Alessandra and Sch{\"u}rr, Andy},
  pages     = {281--298},
  address   = {Cham},
  publisher = {Springer International Publishing},
  abstract  = {In this paper, we present crete, a versatile binary-level concolic testing framework, which features an open and highly extensible architecture allowing easy integration of concrete execution frontends and symbolic execution engine backends. crete's extensibility is rooted in its modular design where concrete and symbolic execution is loosely coupled only through standardized execution traces and test cases. The standardized execution traces are llvm-based, self-contained, and composable, providing succinct and sufficient information for symbolic execution engines to reproduce the concrete executions. We have implemented crete with klee as the symbolic execution engine and multiple concrete execution frontends such as qemu and 8051 Emulator. We have evaluated the effectiveness of crete on GNU Coreutils programs and TianoCore utility programs for UEFI BIOS. The evaluation of Coreutils programs shows that crete achieved comparable code coverage as klee directly analyzing the source code of Coreutils and generally outperformed angr. The evaluation of TianoCore utility programs found numerous exploitable bugs that were previously unreported.},
  isbn      = {978-3-319-89363-1},
}

@InProceedings{Menezes2018,
  author    = {Menezes, Rafael and Rocha, Herbert and Cordeiro, Lucas and Barreto, Raimundo},
  title     = {Map2Check Using LLVM and KLEE},
  booktitle = {Tools and Algorithms for the Construction and Analysis of Systems},
  year      = {2018},
  editor    = {Beyer, Dirk and Huisman, Marieke},
  pages     = {437--441},
  address   = {Cham},
  publisher = {Springer International Publishing},
  abstract  = {Map2Check is a bug hunting tool that automatically checks safety properties in C programs. It tracks memory pointers and variable assignments to check user-specified assertions, overflow, and pointer safety. Here, we extend Map2Check to: (i) simplify the program using Clang/LLVM; (ii) perform a path-based symbolic execution using the KLEE tool; and (iii) transform and instrument the code using the LLVM dynamic information flow. The SVCOMP'18 results show that Map2Check can be effective in generating and checking test cases related to memory management of C programs.},
  isbn      = {978-3-319-89963-3},
}

@InProceedings{Jonavs2018,
  author       = {Jon{\'a}{\v{s}}, Martin and Strej{\v{c}}ek, Jan},
  title        = {Abstraction of Bit-Vector Operations for BDD-Based SMT Solvers},
  booktitle    = {International Colloquium on Theoretical Aspects of Computing},
  year         = {2018},
  pages        = {273--291},
  organization = {Springer},
}

@InProceedings{Ibing2016,
  author    = {Ibing, Andreas},
  title     = {Dynamic symbolic execution with interpolation based path merging},
  booktitle = {Int. Conf. Advances and Trends in Software Engineering},
  year      = {2016},
}

@InProceedings{Gennari2018,
  author       = {Gennari, Jeffrey and Gurfinkel, Arie and Kahsai, Temesghen and Navas, Jorge A and Schwartz, Edward J},
  title        = {Executable Counterexamples in Software Model Checking},
  booktitle    = {Working Conference on Verified Software: Theories, Tools, and Experiments},
  year         = {2018},
  pages        = {17--37},
  organization = {Springer},
}

@Article{Chalupa2019,
  author   = {Chalupa, Marek and Strej{\v{c}}ek, Jan and Vitovsk{\'a}, Martina},
  title    = {Joint forces for memory safety checking revisited},
  journal  = {International Journal on Software Tools for Technology Transfer},
  year     = {2019},
  month    = {Aug},
  issn     = {1433-2787},
  abstract = {We present an improved version of the memory safety verification approach implemented in Symbiotic 5, the winner of the MemSafety category at the Competition on Software Verification (SV-COMP) 2018. The approach can verify programs for standard errors in memory usage like invalid pointer dereference or memory leaking. It is based on instrumentation, static pointer analysis extended to consider memory deallocations, static program slicing, and symbolic execution. The improved version brings higher precision of the extended pointer analysis and further optimizations in instrumentation. It is implemented in the current version of Symbiotic, which contains also some improvements in program slicing and symbolic execution. We explain the approach in theory, describe implementation of selected components, and provide experimental results showing the impact of particular components.},
  day      = {06},
  doi      = {10.1007/s10009-019-00526-2},
  url      = {https://doi.org/10.1007/s10009-019-00526-2},
}

@InProceedings{Olliaro2018,
  author    = {A. {Cortesi} and M. {Olliaro}},
  title     = {M-String Segmentation: A Refined Abstract Domain for String Analysis in C Programs},
  booktitle = {2018 International Symposium on Theoretical Aspects of Software Engineering (TASE)},
  year      = {2018},
  pages     = {1-8},
  month     = {Aug},
  doi       = {10.1109/TASE.2018.00009},
  keywords  = {C language;program diagnostics;programming language semantics;m-string segmentation;refined abstract domain;C programs;refined segmentation abstract domain;C programming language;parametric segmentation approach;array representation;text values;concrete semantics;abstract semantics;main C header file string;string arrays;string analysis;string abstraction;static analysis;abstract interpretation;abstract domain},
}

@Article{Costantini2015,
  author  = {Giulia Costantini and Pietro Ferrara and Agostino Cortesi},
  title   = {A suite of abstract domains for static analysis of string values},
  journal = {Softw., Pract. Exper.},
  year    = {2015},
  volume  = {45},
  pages   = {245-287},
}

@InProceedings{Kim2011,
  author    = {Kim, Se-Won and Choe, Kwang-Moo},
  title     = {String Analysis as an Abstract Interpretation},
  booktitle = {Verification, Model Checking, and Abstract Interpretation},
  year      = {2011},
  editor    = {Jhala, Ranjit and Schmidt, David},
  pages     = {294--308},
  address   = {Berlin, Heidelberg},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {We formalize a string analysis within abstract interpretation framework. The abstraction of strings is given as a conjunction of predicates that describes the common configuration changes on the reference pushdown automaton while processing the strings. We also present a family of pushdown automata called $\epsilon$ bounded pushdown automata. This family covers all context-free languages, and by using this family of pushdown automata, we can prevent abstract values from becoming infinite conjunctions and guarantee that the operations required in the analyzer are computable.},
  isbn      = {978-3-642-18275-4},
}

@InProceedings{Astree,
  author    = {Cousot, Patrick and Cousot, Radhia and Feret, Jer{\^o}me and Mauborgne, Laurent and Min{\'e}, Antoine and Monniaux, David and Rival, Xavier},
  title     = {The ASTRE{\'E} Analyzer},
  booktitle = {Programming Languages and Systems},
  year      = {2005},
  editor    = {Sagiv, Mooly},
  pages     = {21--30},
  address   = {Berlin, Heidelberg},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {ASTR{\'E}E is an abstract interpretation-based static program analyzer aiming at proving automatically the absence of run time errors in programs written in the C programming language. It has been applied with success to large embedded control-command safety critical real-time software generated automatically from synchronous specifications, producing a correctness proof for complex software without any false alarm in a few hours of computation.},
  isbn      = {978-3-540-31987-0},
}

@InProceedings{Delmas2007,
  author    = {Delmas, David and Souyris, Jean},
  title     = {Astr{\'e}e: From Research to Industry},
  booktitle = {Static Analysis},
  year      = {2007},
  editor    = {Nielson, Hanne Riis and Fil{\'e}, Gilberto},
  pages     = {437--451},
  address   = {Berlin, Heidelberg},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {Airbus has started introducing abstract interpretation based static analysers into the verification process of some of its avionics software products. Industrial constraints require any such tool to be extremely precise, which can only be achieved after a twofold specialisation process: first, it must be designed to verify a class of properties for a family of programs efficiently; second, it must be parametric enough for the user to be able to fine tune the analysis of any particular program of the family. This implies a close cooperation between the tool-providers and the end-users. Astr{\'e}e is such a static analyser: it produces only a small number of false alarms when attempting to prove the absence of run-time errors in control/command programs written in C, and provides the user with enough options and directives to help reduce this number down to zero. Its specialisation process has been reported in several scientific papers, such as [1] and [2]. Through the description of analyses performed with Astr{\'e}e on industrial programs, we give an overview of the false alarm reduction process from an engineering point of view, and sketch a possible customer-supplier relationship model for the emerging market for static analysers.},
  isbn      = {978-3-540-74061-2},
}

@InProceedings{Souyris2007,
  author = {Souyris, Jean and Delmas, David},
  title  = {Experimental Assessment of Astrée on Safety-Critical Avionics Software},
  year   = {2007},
  volume = {4680},
  pages  = {479-490},
  month  = {09},
  doi    = {10.1007/978-3-540-75101-4_45},
}

@Article{Bouissou2009,
  author  = {Bouissou, Olivier and Conquet, Eric and Cousot, Patrick and Cousot, Radhia and Feret, Jérôme and Ghorbal, Khalil and Goubault, E and Lesens, David and Mauborgne, Laurent and Miné, Antoine and Putot, Sylvie and Rival, Xavier and Turin, Michel},
  title   = {Space Software Validation using Abstract Interpretation},
  journal = {The International Space System Engineering Conference : Data Systems in Aerospace - DASIA 2009},
  year    = {2009},
  month   = {05},
}

@InProceedings{Mauborgne2005,
  author    = {Mauborgne, Laurent and Rival, Xavier},
  title     = {Trace Partitioning in Abstract Interpretation Based Static Analyzers},
  booktitle = {Proceedings of the 14th European Conference on Programming Languages and Systems},
  year      = {2005},
  series    = {ESOP'05},
  pages     = {5--20},
  address   = {Berlin, Heidelberg},
  publisher = {Springer-Verlag},
  acmid     = {2140710},
  doi       = {10.1007/978-3-540-31987-0_2},
  isbn      = {3-540-25435-8, 978-3-540-25435-5},
  location  = {Edinburgh, UK},
  numpages  = {16},
  url       = {http://dx.doi.org/10.1007/978-3-540-31987-0_2},
}

@InProceedings{Feret2004,
  author    = {Feret, J{\'e}r{\^o}me},
  title     = {Static Analysis of Digital Filters},
  booktitle = {Programming Languages and Systems},
  year      = {2004},
  editor    = {Schmidt, David},
  pages     = {33--48},
  address   = {Berlin, Heidelberg},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {We present an Abstract Interpretation-based framework for automatically analyzing programs containing digital filters. Our framework allows refining existing analyses so that they can handle given classes of digital filters. We only have to design a class of symbolic properties that describe the invariants throughout filter iterations, and to describe how these properties are transformed by filter iterations. Then, the analysis allows both inference and proofs of the properties about the program variables that are tied to any such filter.},
  isbn      = {978-3-540-24725-8},
}

@InProceedings{Feret2005,
  author    = {Feret, J{\'e}r{\^o}me},
  title     = {The Arithmetic-Geometric Progression Abstract Domain},
  booktitle = {Verification, Model Checking, and Abstract Interpretation},
  year      = {2005},
  editor    = {Cousot, Radhia},
  pages     = {42--58},
  address   = {Berlin, Heidelberg},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {We present a new numerical abstract domain. This domain automatically detects and proves bounds on the values of program variables. For that purpose, it relates variable values to a clock counter. More precisely, it bounds these values with the i-th iterate of the function [X↦$\alpha${\texttimes}X{\thinspace}+{\thinspace}$\beta$] applied on M, where i denotes the clock counter and the floating-point numbers $\alpha$, $\beta$, and M are discovered by the analysis. Such properties are especially useful to analyze loops in which a variable is iteratively assigned with a barycentric mean of the values that were associated with the same variable at some previous iterations. Because of rounding errors, the computation of this barycenter may diverge when the loop is iterated forever. Our domain provides a bound that depends on the execution time of the program.},
  isbn      = {978-3-540-30579-8},
}

@InProceedings{Gershuni2019,
  author    = {Gershuni, Elazar and Amit, Nadav and Gurfinkel, Arie and Narodytska, Nina and Navas, Jorge A. and Rinetzky, Noam and Ryzhyk, Leonid and Sagiv, Mooly},
  title     = {Simple and Precise Static Analysis of Untrusted Linux Kernel Extensions},
  booktitle = {Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  year      = {2019},
  series    = {PLDI 2019},
  pages     = {1069--1084},
  address   = {New York, NY, USA},
  publisher = {ACM},
  acmid     = {3314590},
  doi       = {10.1145/3314221.3314590},
  isbn      = {978-1-4503-6712-7},
  keywords  = {ebpf, kernel extensions, linux, static analysis},
  location  = {Phoenix, AZ, USA},
  numpages  = {16},
  url       = {http://doi.acm.org/10.1145/3314221.3314590},
}

@InProceedings{Ikos,
  author    = {Brat, Guillaume and Navas, Jorge A. and Shi, Nija and Venet, Arnaud},
  title     = {IKOS: A Framework for Static Analysis Based on Abstract Interpretation},
  booktitle = {Software Engineering and Formal Methods},
  year      = {2014},
  editor    = {Giannakopoulou, Dimitra and Sala{\"u}n, Gwen},
  pages     = {271--277},
  address   = {Cham},
  publisher = {Springer International Publishing},
  abstract  = {The RTCA standard (DO-178C) for developing avionic software and getting certification credits includes an extension (DO-333) that describes how developers can use static analysis in certification. In this paper, we give an overview of the IKOS static analysis framework that helps developing static analyses that are both precise and scalable. IKOS harnesses the power of Abstract Interpretation and makes it accessible to a larger class of static analysis developers by separating concerns such as code parsing, model development, abstract domain management, results management, and analysis strategy. The benefits of the approach is demonstrated by a buffer overflow analysis applied to flight control systems.},
  isbn      = {978-3-319-10431-7},
}

@Article{Sen2005,
  author     = {Sen, Koushik and Marinov, Darko and Agha, Gul},
  title      = {CUTE: A Concolic Unit Testing Engine for C},
  journal    = {SIGSOFT Softw. Eng. Notes},
  year       = {2005},
  volume     = {30},
  number     = {5},
  pages      = {263--272},
  month      = sep,
  issn       = {0163-5948},
  acmid      = {1081750},
  address    = {New York, NY, USA},
  doi        = {10.1145/1095430.1081750},
  issue_date = {September 2005},
  keywords   = {concolic testing, data structure testing, explicit path model-checking, random testing, testing C programs, unit testing},
  numpages   = {10},
  publisher  = {ACM},
  url        = {http://doi.acm.org/10.1145/1095430.1081750},
}

@Article{Kanvar2016,
  author     = {Kanvar, Vini and Khedker, Uday P.},
  title      = {Heap Abstractions for Static Analysis},
  journal    = {ACM Comput. Surv.},
  year       = {2016},
  volume     = {49},
  number     = {2},
  pages      = {29:1--29:47},
  month      = jun,
  issn       = {0360-0300},
  acmid      = {2931098},
  address    = {New York, NY, USA},
  articleno  = {29},
  doi        = {10.1145/2931098},
  issue_date = {November 2016},
  keywords   = {Abstraction, heap, pointers, shape analysis, static analysis, store based, storeless, summarization},
  numpages   = {47},
  publisher  = {ACM},
  url        = {http://doi.acm.org/10.1145/2931098},
}

@InProceedings{Holik2015,
  author    = {Hol{\'i}k, Luk{\'a}{\v{s}} and Hru{\v{s}}ka, Martin and Leng{\'a}l, Ond{\v{r}}ej and Rogalewicz, Adam and {\v{S}}im{\'a}{\v{c}}ek, Ji{\v{r}}{\'i} and Vojnar, Tom{\'a}{\v{s}}},
  title     = {Forester: Shape Analysis Using Tree Automata},
  booktitle = {Tools and Algorithms for the Construction and Analysis of Systems},
  year      = {2015},
  editor    = {Baier, Christel and Tinelli, Cesare},
  pages     = {432--435},
  address   = {Berlin, Heidelberg},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {Forester is a tool for shape analysis of programs with complex dynamic data structures---including various flavours of lists (such as singly/doubly linked lists, nested lists, or skip lists) as well as trees and other complex data structures---that uses an abstract domain based on finite tree automata. This paper gives a brief description of the verification approach of Forester and discusses its strong and weak points revealed during its participation in SV-COMP'15.},
  isbn      = {978-3-662-46681-0},
}

@InProceedings{Dudka2012,
  author       = {Dudka, Kamil and M{\"u}ller, Petr and Peringer, Petr and Vojnar, Tom{\'a}{\v{s}}},
  title        = {PREDATOR: A verification tool for programs with dynamic linked data structures},
  booktitle    = {International Conference on Tools and Algorithms for the Construction and Analysis of Systems},
  year         = {2012},
  pages        = {545--548},
  organization = {Springer},
}

@InProceedings{Neider2018,
  author    = {Neider, Daniel and Garg, Pranav and Madhusudan, P. and Saha, Shambwaditya and Park, Daejun},
  title     = {Invariant Synthesis for Incomplete Verification Engines},
  booktitle = {Tools and Algorithms for the Construction and Analysis of Systems},
  year      = {2018},
  editor    = {Beyer, Dirk and Huisman, Marieke},
  pages     = {232--250},
  address   = {Cham},
  publisher = {Springer International Publishing},
  abstract  = {We propose a framework for synthesizing inductive invariants for incomplete verification engines, which soundly reduce logical problems in undecidable theories to decidable theories. Our framework is based on the counter-example guided inductive synthesis principle (CEGIS) and allows verification engines to communicate non-provability information to guide invariant synthesis. We show precisely how the verification engine can compute such non-provability information and how to build effective learning algorithms when invariants are expressed as Boolean combinations of a fixed set of predicates. Moreover, we evaluate our framework in two verification settings, one in which verification engines need to handle quantified formulas and one in which verification engines have to reason about heap properties expressed in an expressive but undecidable separation logic. Our experiments show that our invariant synthesis framework based on non-provability information can both effectively synthesize inductive invariants and adequately strengthen contracts across a large suite of programs.},
  isbn      = {978-3-319-89960-2},
}

@InProceedings{Piskac2013,
  author       = {Piskac, Ruzica and Wies, Thomas and Zufferey, Damien},
  title        = {Automating separation logic using SMT},
  booktitle    = {International Conference on Computer Aided Verification},
  year         = {2013},
  pages        = {773--789},
  organization = {Springer},
}

@Article{Itzhaky2014,
  author    = {Itzhaky, Shachar and Banerjee, Anindya and Immerman, Neil and Lahav, Ori and Nanevski, Aleksandar and Sagiv, Mooly},
  title     = {Modular reasoning about heap paths via effectively propositional formulas},
  journal   = {ACM SIGPLAN Notices},
  year      = {2014},
  volume    = {49},
  number    = {1},
  pages     = {385--396},
  publisher = {ACM},
}

@InProceedings{Itzhaky2014b,
  author    = {Itzhaky, Shachar and Bjorner, Nikolaj and Reps, Thomas and Sagiv, Mooly and Thakur, Aditya},
  title     = {Property-Directed Shape Analysis},
  booktitle = {Proceedings of the 16th International Conference on Computer Aided Verification - Volume 8559},
  year      = {2014},
  pages     = {35--51},
  address   = {Berlin, Heidelberg},
  publisher = {Springer-Verlag},
  acmid     = {2735054},
  doi       = {10.1007/978-3-319-08867-9_3},
  isbn      = {978-3-319-08866-2},
  numpages  = {17},
  url       = {https://doi.org/10.1007/978-3-319-08867-9_3},
}

@InProceedings{Putot2004,
  author    = {Putot, Sylvie and Goubault, Eric and Martel, Matthieu},
  title     = {Static Analysis-Based Validation of Floating-Point Computations},
  booktitle = {Numerical Software with Result Verification},
  year      = {2004},
  editor    = {Alt, Ren{\'e} and Frommer, Andreas and Kearfott, R. Baker and Luther, Wolfram},
  pages     = {306--313},
  address   = {Berlin, Heidelberg},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {Finite precision computations can severely affect the accuracy of computed solutions. We present a static analysis, and a prototype implementing this analysis for C codes, for studying the propagation of rounding errors occurring at every intermediary step in floating-point computations. The analysis presented relies on abstract interpretation by interval values and series of interval error terms. Considering all errors possibly introduced by floating-point numbers, it aims at identifying the operations responsible for the main losses of accuracy. We believe this approach is for now specially appropriate for numerically simple programs which results must be verified, such as critical instrumentation software.},
  isbn      = {978-3-540-24738-8},
}

@InProceedings{Stepanov2015,
  author       = {Stepanov, Evgeniy and Serebryany, Konstantin},
  title        = {MemorySanitizer: fast detector of uninitialized memory use in C++},
  booktitle    = {Proceedings of the 13th Annual IEEE/ACM International Symposium on Code Generation and Optimization},
  year         = {2015},
  pages        = {46--55},
  organization = {IEEE Computer Society},
}

@InProceedings{,
}

@InProceedings{Lauko2019String,
  author    = {Cortesi, Agostino and Lauko, Henrich and Olliaro, Martina and Ro{\v{c}}kai, Petr},
  title     = {String abstraction for model checking of C programs},
  booktitle = {Model Checking Software},
  year      = {2019},
  pubstate  = {\bibstring{toappear}},
}

@Comment{jabref-meta: databaseType:bibtex;}
