\chapter{introduction}
\label{ch:intro}

% Stručné uvedení do problematiky, motivace, přehled dalších kapitol, 2 - 3 strany.

Contemporary research in computer science is increasingly characterized by
an overwhelming number of new techniques, tools, and algorithms.  However, many
of them are not designed with reusability in mind.  This trend causes
researchers to reimplement standard techniques by themselves whenever they want
to extend or adapt existing work.  The reimplementation does not just require
extra time resources, but also produces results hardly comparable with previous
approaches because the performance is becoming implementation-dependent.

The computer-aided verification community is not an exception. The goal of
verification is to decide whether a system under test satisfies a given
specification. Even though this task is generally undecidable; many verifiers
are able to reason about complex systems. The technique that enables
verification tools to handle such complex systems is an abstraction. In
general, the abstraction reduces the amount of information that the verifier is
reasoning about, consequently reducing program state-space, but for the price
of approximated result. This can be achieved, for example, by maintaining only
specific properties of program values. Because abstraction based techniques are
indispensable for successful verification of larger models, the verification
community is being flooded with their implementations.  According to
the classification of techniques used in the recent verification competition
\svcomp~\cite{SVCOMP2019}, many tools utilize a similar set of abstraction
techniques (see \autoref{tab:svcomp}) concretely: predicate abstraction
\cite{Flanagan02},  coun\-ter\-example-guided abstraction refinement (\cegar)
\cite{Clarke20}, shape analysis \cite{Yang2008}, lazy abstraction
\cite{Henzinger2002}, or symbolic data representation
\cite{King76,Burch1990,Majumdar2018}. Though, these techniques share similar
ideas, each of the tools ships with its own implementation.  Moreover, the
design of these algorithms is not well suited for reusability.

\begin{table}[ht]

	\centering
    \resizebox{\textwidth}{!}{%
    \newcolumntype{C}{>{\sffamily}l}
    \begin{tabular}{C |  g c g c g c g c g c g c g c g c g c}
        \textsc{participant}
        & \rotatebox{90}{\cegar}
        & \rotatebox{90}{Predicate Abstraction}
        & \rotatebox{90}{Symbolic Execution}
        & \rotatebox{90}{Bounded Model Checking}
        & \rotatebox{90}{k-Induction}
        & \rotatebox{90}{Property-Directed Reach.}
        & \rotatebox{90}{Explicit-Value Analysis}
        & \rotatebox{90}{Numeric. Interval Analysis}
        & \rotatebox{90}{Shape Analysis}
        & \rotatebox{90}{Separation Logic}
        & \rotatebox{90}{Bit-Precise Analysis}
        & \rotatebox{90}{ARG-Based Analysis}
        & \rotatebox{90}{Lazy Abstraction}
        & \rotatebox{90}{Interpolation}
        & \rotatebox{90}{Automata-Based Analysis}
        & \rotatebox{90}{Concurrency Support}
        & \rotatebox{90}{Ranking Functions}
        & \rotatebox{90}{Evolutionary Algorithms}
        \\
 	\hline
    2LS             &  &  &  & \cm & \cm &  &  & \cm &  &  & \cm &  &  &  &  &  & \cm &  \\
    AProVE          &  &  & \cm &  &  &  & \cm & \cm &  & \cm & \cm &  &  &  &  &  & \cm &  \\
    \hline
    CBMC            &  &  &  & \cm &  &  &  &  &  &  & \cm &  &  &  &  & \cm &  &  \\
    CBMC-Path       &  &  &  & \cm &  &  &  &  &  &  & \cm &  &  &  &  & \cm &  &  \\
    \hline
    CPA-BAM-BnB     & \cm & \cm &  &  &  &  & \cm &  &  &  & \cm & \cm & \cm & \cm &  &  &  &  \\
    CPA-Lockator    & \cm & \cm &  &  &  &  & \cm &  &  &  & \cm & \cm & \cm & \cm &  & \cm &  &  \\
    \hline
    CPA-Seq         & \cm  & \cm &  & \cm & \cm &  & \cm & \cm & \cm &  & \cm & \cm & \cm & \cm &  & \cm & \cm &  \\
    DepthK          &  &  &  & \cm & \cm &  &  &  &  &  & \cm &  &  &  &  & \cm &  &  \\
    \hline
    DIVINE-explicit &  &  &  &  &  &  & \cm &  &  &  & \cm &  &  &  &  & \cm &  &  \\
    DIVINE-SMT      &  &  &  &  &  &  & \cm &  &  &  & \cm &  &  &  &  & \cm &  &  \\
    \hline
    ESBMC-kind      &  &  &  & \cm & \cm &  &  &  &  &  & \cm &  &  &  &  & \cm &  &  \\
    JayHorn         & \cm & \cm &  &  &  & \cm &  & \cm &  &  &  &  & \cm & \cm &  &  &  &  \\
    \hline
    JBMC            &  &  &  & \cm &  &  &  &  &  &  & \cm &  &  &  &  & \cm &  &  \\
    JPF             &  &  &  & \cm &  &  & \cm & \cm &  &  & \cm &  &  &  &  &  &  &  \\
    \hline
    Lazy-CSeq       &  &  &  & \cm &  &  &  &  &  &  & \cm &  &  &  &  & \cm  &  &  \\
    Map2Check       &  &  &  & \cm &  &  &  &  &  &  & \cm &  &  &  &  &  &  &  \\
    \hline
    PeSCo           & \cm & \cm &  & \cm & \cm &  & \cm & \cm & \cm &  & \cm & \cm & \cm & \cm &  & \cm & \cm &  \\
    Pinaka          &  &  & \cm & \cm &  &  &  &  &  &  & \cm &  &  &  &  &  &  &  \\
    \hline
    PredatorHP      &  &  &  &  &  &  &  &  & \cm &  &  &  &  &  &  &  &  &  \\
    Skink           & \cm &  &  &  &  &  & \cm &  &  &  &  &  &  & \cm & \cm &  &  &  \\
    \hline
    Smack           & \cm &  &  & \cm &  & \cm &  &  &  &  & \cm &  & \cm &  &  & \cm &  &  \\
    SPF             &  &  & \cm &  &  &  &  &  & \cm &  &  &  &  &  &  & \cm &  &  \\
    \hline
    Symbiotic       &  &  & \cm &  &  &  &  & \cm &  &  & \cm &  &  &  &  &  &  &  \\
    UAutomizer      & \cm & \cm &  &  &  &  &  &  &  &  & \cm &  & \cm & \cm & \cm &  & \cm &  \\
	\hline
    UKojak          & \cm & \cm &  &  &  &  &  &  &  &  & \cm &  & \cm & \cm &  &  &  &  \\
    UTaipan         & \cm & \cm &  &  &  &  &  &  &  &  & \cm &  & \cm & \cm & \cm &  &  &  \\
	\hline
    VeriAbs         & \cm &  &  & \cm & \cm &  & \cm & \cm &  &  &  &  &  &  &  &  &  &  \\
    VeriFuzz        &  &  &  & \cm &  &  &  & \cm &  &  &  &  &  &  &  &  &  & \cm \\
	\hline
    VIAP            &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  \\
    Yogar-CBMC      & \cm &  &  & \cm &  &  &  &  &  &  & \cm &  & \cm &  &  & \cm &  &  \\
	\hline
    Yogar-CBMC-Par. & \cm &  &  & \cm &  &  &  &  &  &  & \cm &  & \cm &  &  & \cm &  &  \\
	\end{tabular}
    }

\caption{Techniques that the \svcomp 2019 candidates offer \cite{SVCOMP2019}.}
\label{tab:svcomp}
\end{table}

In the program verification, abstraction is applied on many levels of the
system.  One of them is a model on which the verifier operates. In general, it
would be impractical if not impossible to verify the whole software stack, from
the bottom of the hardware layer, throughout an operating system environment to
the top, the actual program under test. Hence, the verifier abstracts from the
environment and reasons only about the program and a subset of its environment.
The program representation can also be abstracted.  Usually, it is inconvenient
to process the original form of a program. Therefore, many tools firstly
translate the program into a simpler verification friendly format  (e.g.,
byte-code intermediate representation or a program graph).

However, the abstraction that we will be interested in is an abstraction of
program environment, also addressed as non-deter\-mi\-ni\-stic inputs to the program.
For full coverage of verification, it is required to examine the unpredictable
behavior of interaction with the program environment. Hence, the verification
tool needs to consider all possible program behaviors (e.g., program inputs).
To manage an enormous number of possibilities, verifiers utilize abstraction to
group similar behaviors and consequently reason only about a reduced number of
options. Alternatively, verification tools use abstraction to preserve only
those behaviors that are interesting for the verified property.

In this thesis proposal, I investigate how to adapt abstraction-related
techniques used in verification tools as stand-alone algorithms. This involves
the identification of common properties of the abovementioned techniques and
based on that development of new self-con\-tained algorithms, as well as a
design of an interface between newly developed algorithms and verification
tools. Moreover, I intend to create an accessible framework for simple
construction and testing of new abstract domains. With the power of stand-alone
abstraction, these abstract domains can then be easily used by dynamic
analyses. Furthermore, the inherent advantage gained by removing the
abstraction engine out of a verification tool is its simplification --
therefore a more robust verification.

There exist many possible approaches how to refactor abstraction out of the
verification tools. In my research, I focus on a single particular approach
where the responsibility for the abstract computation is moved from the
interpreter to the precedent static transformation. The static transformation
takes care of instrumentation of the abstraction directly into the program.
Hence, the program will maintain abstract data and perform abstract operations
instead of concrete computation. Conse\-quen\-tly, the interpreter can interpret
the instrumented program without any knowledge of abstract semantics.

In the rest of the proposal, I will first present the state-of-the-art
abstraction techniques in \autoref{ch:state}.  The following \autoref{ch:aim}
examines the presented approaches and states the challenges of reusable
abstraction design, as well as the aims of my thesis. Moreover, I
introduce the notion of a transformation-based abstraction, which is one of the
possible solutions for the stated objectives. Finally, in the
\autoref{ch:results}, I present my achieved results in transformation-based
approach to abstraction.
