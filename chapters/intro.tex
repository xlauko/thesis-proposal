\chapter{Introduction}
\label{ch:intro}

% Stručné uvedení do problematiky, motivace, přehled dalších kapitol, 2 - 3 strany.

The contemporary research in computer science is increasingly characterized by
an overwhelming number of new techniques, tools, and algorithms.  However, many
of them are not designed with reusability in mind.  This trend causes
researchers to reimplement many of algorithms by themselves if they want to
extend existing work.  The reimplementation does not just require extra time
resources, but also produces hardly comparable results with previous approaches
because the evaluation is becoming implementation-dependent.

The computer-aided verification community is not an exception.
According to the classification of used techniques in recent \svcomp \cite{SVCOMP2019}, many tools utilize a similar set of core techniques (see \autoref{tab:svcomp}).

%\add{ verification motivation? }

The prominent role of presented approaches is taken by \emph{abstraction} related techniques, concretely \cegar
\cite{Clarke20}, predicate abstraction \cite{Flanagan02}, shape analysis \cite{Yang2008}, lazy abstraction \cite{Henzinger2002}, or symbolic data representation \cite{King76,Burch1990,Majumdar2018}.
Even though these techniques share similar ideas each of the tools ship with their own implementation.
Moreover, the design of these algorithms is not well suited for reusability.

% besides sv-comp abstraction is widely adopted to tackle .... (google scholar citation)

On the other hand, we may also find examples of reusable techniques.  One such
example is the utilization of \smt logics and solvers in the symbolic
verification.  With widely adopted format SMT-LIB \cite{Barrett2010}, \smt
solvers are easily used out-of-the-box \cite{Dutertre2006, DeMoura2008, Barrett2011, Corzilius2015}.

In general, a goal of computer-aided verification is to decide whether a system
under test satisfies a given specification.  Nevertheless, the verification
task is undecidable; many verifiers can reason about complex systems. This
would not be possible without the abstraction of system behaviors.

In the verification, the abstraction is applied on many levels of the system.
One of them is a model on which the verifier operates. In general, it would be
impractical if not impossible to verify the whole software stack, from the
bottom of the hardware layer, throughout an operating system environment to the
top -- the actual program under test. Hence the verifier abstract from the
environment and reason only about the program. The program representation can
also be abstracted; the verifier process either the original form of it or
translates the program to more verifier friendly format (e.g., byte-code
intermediate representation or program graph).

However, the abstraction that we will be interested in this thesis proposal is
a non-deterministic data abstraction. It is required to examine the
unpredictable behavior of interaction with the program environment. To soundly
handle the non-determinism, the verifier needs to explore all possible program
behaviors (e.g., program inputs). To manage an enormous amount of
possibilities, verifiers utilize abstraction to group similar behaviors and
reason about a reduced amount of options. Or they use the abstraction to
preserve only those behaviors that are interesting for a verified property.

As we have noted before, the abstraction techniques are broadly employed in
state-of-the-art tools. However, their design is usually not well suited for
sharing among the tools. Hence in this thesis proposal, we are going to
investigate how to adapt existing abstraction techniques to become reusable.
Moreover, we will aim at a design of abstraction that will allow researchers to
develop abstractions and reevaluate them across multiple tools without being
implementation-dependent.

\begin{table}[h]

	\centering
    \resizebox{\textwidth}{!}{%
    \newcolumntype{C}{>{\sffamily}l}
    \begin{tabular}{C |  g c g c g c g c g c g c g c g c g c}
        \textsc{participant}
        & \rotatebox{90}{\cegar}
        & \rotatebox{90}{Predicate Abstraction}
        & \rotatebox{90}{Symbolic Execution}
        & \rotatebox{90}{Bounded Model Checking}
        & \rotatebox{90}{k-Induction}
        & \rotatebox{90}{Property-Directed Reach.}
        & \rotatebox{90}{Explicit-Value Analysis}
        & \rotatebox{90}{Numeric. Interval Analysis}
        & \rotatebox{90}{Shape Analysis}
        & \rotatebox{90}{Separation Logic}
        & \rotatebox{90}{Bit-Precise Analysis}
        & \rotatebox{90}{ARG-Based Analysis}
        & \rotatebox{90}{Lazy Abstraction}
        & \rotatebox{90}{Interpolation}
        & \rotatebox{90}{Automata-Based Analysis}
        & \rotatebox{90}{Concurrency Support}
        & \rotatebox{90}{Ranking Functions}
        & \rotatebox{90}{Evolutionary Algorithms}
        \\
 	\hline
    2LS             &  &  &  & \cm & \cm &  &  & \cm &  &  & \cm &  &  &  &  &  & \cm &  \\
    AProVE          &  &  & \cm &  &  &  & \cm & \cm &  & \cm & \cm &  &  &  &  &  & \cm &  \\
    \hline
    CBMC            &  &  &  & \cm &  &  &  &  &  &  & \cm &  &  &  &  & \cm &  &  \\
    CBMC-Path       &  &  &  & \cm &  &  &  &  &  &  & \cm &  &  &  &  & \cm &  &  \\
    \hline
    CPA-BAM-BnB     & \cm & \cm &  &  &  &  & \cm &  &  &  & \cm & \cm & \cm & \cm &  &  &  &  \\
    CPA-Lockator    & \cm & \cm &  &  &  &  & \cm &  &  &  & \cm & \cm & \cm & \cm &  & \cm &  &  \\
    \hline
    CPA-Seq         & \cm  & \cm &  & \cm & \cm &  & \cm & \cm & \cm &  & \cm & \cm & \cm & \cm &  & \cm & \cm &  \\
    DepthK          &  &  &  & \cm & \cm &  &  &  &  &  & \cm &  &  &  &  & \cm &  &  \\
    \hline
    DIVINE-explicit &  &  &  &  &  &  & \cm &  &  &  & \cm &  &  &  &  & \cm &  &  \\
    DIVINE-SMT      &  &  &  &  &  &  & \cm &  &  &  & \cm &  &  &  &  & \cm &  &  \\
    \hline
    ESBMC-kind      &  &  &  & \cm & \cm &  &  &  &  &  & \cm &  &  &  &  & \cm &  &  \\
    JayHorn         & \cm & \cm &  &  &  & \cm &  & \cm &  &  &  &  & \cm & \cm &  &  &  &  \\
    \hline
    JBMC            &  &  &  & \cm &  &  &  &  &  &  & \cm &  &  &  &  & \cm &  &  \\
    JPF             &  &  &  & \cm &  &  & \cm & \cm &  &  & \cm &  &  &  &  &  &  &  \\
    \hline
    Lazy-CSeq       &  &  &  & \cm &  &  &  &  &  &  & \cm &  &  &  &  & \cm  &  &  \\
    Map2Check       &  &  &  & \cm &  &  &  &  &  &  & \cm &  &  &  &  &  &  &  \\
    \hline
    PeSCo           & \cm & \cm &  & \cm & \cm &  & \cm & \cm & \cm &  & \cm & \cm & \cm & \cm &  & \cm & \cm &  \\
    Pinaka          &  &  & \cm & \cm &  &  &  &  &  &  & \cm &  &  &  &  &  &  &  \\
    \hline
    PredatorHP      &  &  &  &  &  &  &  &  & \cm &  &  &  &  &  &  &  &  &  \\
    Skink           & \cm &  &  &  &  &  & \cm &  &  &  &  &  &  & \cm & \cm &  &  &  \\
    \hline
    Smack           & \cm &  &  & \cm &  & \cm &  &  &  &  & \cm &  & \cm &  &  & \cm &  &  \\
    SPF             &  &  & \cm &  &  &  &  &  & \cm &  &  &  &  &  &  & \cm &  &  \\
    \hline
    Symbiotic       &  &  & \cm &  &  &  &  & \cm &  &  & \cm &  &  &  &  &  &  &  \\
    UAutomizer      & \cm & \cm &  &  &  &  &  &  &  &  & \cm &  & \cm & \cm & \cm &  & \cm &  \\
	\hline
    UKojak          & \cm & \cm &  &  &  &  &  &  &  &  & \cm &  & \cm & \cm &  &  &  &  \\
    UTaipan         & \cm & \cm &  &  &  &  &  &  &  &  & \cm &  & \cm & \cm & \cm &  &  &  \\
	\hline
    VeriAbs         & \cm &  &  & \cm & \cm &  & \cm & \cm &  &  &  &  &  &  &  &  &  &  \\
    VeriFuzz        &  &  &  & \cm &  &  &  & \cm &  &  &  &  &  &  &  &  &  & \cm \\
	\hline
    VIAP            &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  \\
    Yogar-CBMC      & \cm &  &  & \cm &  &  &  &  &  &  & \cm &  & \cm &  &  & \cm &  &  \\
	\hline
    Yogar-CBMC-Par. & \cm &  &  & \cm &  &  &  &  &  &  & \cm &  & \cm &  &  & \cm &  &  \\
	\end{tabular}
    }

\caption{Techniques that the \svcomp 2019 candidates offer \cite{SVCOMP2019}.}
\label{tab:svcomp}
\end{table}

The rest of the proposal is organized as follows: \autoref{ch:state} summarizes the state of the art of approximation techniques, the \autoref{sec:preliminaries} present a common notation used in following chapters, followed by introduction to an abstraction (\autoref{sec:abstraction}) and summary of abstract domains \autoref{sec:domains}. The second half of \autoref{ch:state} investigates abstraction-based techniques used in computer-aided verification (\autoref{sec:techniques}).

The following \autoref{ch:aim} examines the presented approaches and states the
challenges of reusable abstraction design, as well as aims of my thesis. We
introduce a notion of a transformation-based abstraction, which is one of the
possible solutions for the stated objectives.

The last chapter (\autoref{ch:results}) presents already achieved results in
transformation-based approach.  \autoref{sec:symbolic} investigates how we have
adapted a symbolic abstraction for explicit-based model checking
\cite{Lauko2019Sym, Lauko2018SymComp}. Further in \autoref{sec:string}, we
pre\-sent an extended transformation-based abstraction for string-ma\-ni\-pu\-la\-ting
programs~\cite{Lauko2019String}.  In the end (\autoref{sec:publications}), the
chapter lists my already published papers related to abstraction techniques.
