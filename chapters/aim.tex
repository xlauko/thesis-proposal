\chapter{Aims of the thesis}
\label{ch:aim}

% Stanovení cílů a metodologie disertační práce ("co, proč, jak"), očekávané výsledky, dosažené výsledky, časový harmonogram dalšího postupu, alespoň 2 strany.

Generally, techniques presented in the previous chapter are implemented as
dynamic analysis (i.e. the abstraction is performed on the fly inside of the
program interpreter).  In my research I focus on the development of
repurposable abstraction techniques. To achieve this, we need to extract
abstraction out of the tools and redesign the algorithms to provide sufficient
information for the program analysis. The similar shifting of responsibilities
is already known technique in computer science -- an example are compiled and
interpreted languages, that shifts various tasks between compilation time and
actual run time. In my work, I investigate how much it is possible to move
abstraction to the compilation. Naturally, there exist many possible boundaries
between abstraction and execution engine -- each defined by how much of the
actual abstract interpretation is performed by the program or executor.

As listed in \autoref{sec:ingredients} the abstract domain is determined by
three components (value representation, operators, and iteration strategy).
Each of these components can be positioned on a different side of the boundary.

The typical approach in abstract interpreters is to keep all of them inside of
the interpreter. However, we can let the program to maintain abstract data and
instrument abstract operations into the program (realize them as a concrete
code). Therefore the execution engine will be only responsible for iteration
strategy and refinement.

To minimize the loss of precision, we usually only want to abstract
nondeterministic data of the program. Hence the analysis needs to decide which
operations will be abstracted. Another possibility is to dynamically determine
whether to perform an abstract or concrete operation. This decision can also be
moved between the program under analysis and execution engine. Usually, to
perform such a decision, the engine keeps track of additional metadata
associated with the values, which will determine whether the value is concrete
or not.

Another part of abstraction execution is a decision procedure which determines
the feasibility of a program path. One can argue that it can also be extracted
out of the execution engine for our purpose.

\begin{figure}[h]
    \begin{minipage}[t]{0.45\textwidth}
        test
    \begin{tikzpicture}
    \end{tikzpicture}
    \end{minipage}
    \hfill
    \begin{minipage}[t]{0.45\textwidth}
        test
    \begin{tikzpicture}
    \end{tikzpicture}
    \end{minipage}

    \begin{minipage}[t]{0.45\textwidth}
        test
    \begin{tikzpicture}
    \end{tikzpicture}
    \end{minipage}
    \hfill
    \begin{minipage}[t]{0.45\textwidth}
        test
    \begin{tikzpicture}
    \end{tikzpicture}
    \end{minipage}

\caption{Abstraction boundaries}
\end{figure}

% TODO nondeterministic control flow

% describe boundaries between program and execution engine
% 1. pure program + abstract engine
% 2. abstract program + engine with metadata
% 3. abstracted program with metadata  +  concrete engine
% 4. abstracted program with decision procedure + concrete execution

\section{Objectives and Expected Results}
\label{sec:objectives}

\subsection{Data flow analysis}

\subsubsection{Memory-aware data flow analysis}

\subsubsection{Indirect calls analysis}

\subsection{Trivially constrainable domains}

\subsubsection{SMT inspired refinement techniques}

\add{ bitwidth abstraction }

\add{ theory refinement}

\add{ function summarization }

\subsection{Non-relational abstract domains}

\add{ backward constraint propagation }

\subsection{ Domain categories }

\add{ scalar domains }

\add{ aggregate domains }

% aggregate domains (abstract only offset)

\add{ pointer domains }

% pointer domains (abstract address/offset)

\subsection{Abstraction refinement}

\add{ refinement steps }

\add{ counterexample encoding }

% refinement techniques from chapter 2

% variables packing

% abstraction encoding

\subsection{ Executable abstraction }

% automatic testing of abstract domains \cite{Bugariu2018}

\section{Progression Schedule}
